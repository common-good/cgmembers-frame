<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;

require_once __DIR__ . '/txentry.class';

/**
 * @file
 * CG credit Transaction class
 *
 * Note that a transaction has at least two entries, which this class refers to
 */

class Tx {
  const REQUIRED_FIELDS = 'goods actorId flags';
  const INSERT_FIELDS = self::REQUIRED_FIELDS . ' actorAgentId channel boxId goods risk risks recursId reversesXid created';
  const ALLOWED_FIELDS = self::INSERT_FIELDS . ' entries xid';
  const TX_FIELDS = self::INSERT_FIELDS . ' xid';

  public $xid;
  public $type;
  public $goods;
  public $actorId;
  public $actorAgentId;
  public $flags;
  public $channel;
  public $boxId;
  public $risk;
  public $risks;
  public $recursId;
  public $reversesXid;
  public $created;
  public $entries;
  
  /**
   * Instantiate (construct) a transaction record.
   * @param assoc $info: array of field values for new transaction, must include REQUIRED_FIELD entries,
   *                     but must only include ALLOWED_FIELD entries.
   */
  function __construct($info) {
    $tx = $this;
    u\vetObjectInfo($info, self::ALLOWED_FIELDS, self::REQUIRED_FIELDS, 'Tx');

    foreach (ray(self::TX_FIELDS) as $k) $tx->$k = array_key_exists($k, $info) ? $info[$k] : (in($k, 'xid flags risks channel') ? 0 : NULL);
    $tx->created = u\setDft($info['created'], now());
    $tx->entries = u\setDft($info['entries'], []);
  }

  /**
   * Return the value of the specified field that is not a simple property of the class.
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($f) {
    $tx = $this;
    global $mya;
    $myid = $mya ? $mya->id : NULL;
    
    switch ($f) {
    case 'actorEntry': return $tx->getActorEntry();
    case 'otherEntry': 
      return $tx->primeEntry1->uid == $tx->actorId ? $tx->primeEntry2 
      : ($tx->primeEntry2->uid == $tx->actorId ? $tx->primeEntry1 : NULL);
    case 'payerEntry': return $tx->getPayerEntry();
    case 'payeeEntry': return $tx->getPayeeEntry();
    case 'primeEntry1': return $tx->getE(0); // primary payer
    case 'primeEntry2': return $tx->getE(1); // primary payee
    case 'payerId': return $tx->payerEntry->uid;
    case 'payeeId': return $tx->payeeEntry->uid;

    case 'e1': return $tx->getPayerEntry();
    case 'e2': return $tx->getPayeeEntry();
    case 'uid1': return $tx->e1->uid;
    case 'uid2': return $tx->e2->uid;
    case 'agt1': return $tx->e1->agentUid;
    case 'agt2': return $tx->e2->agentUid;
    case 'a1': return r\acct($tx->uid1, $tx->agt1);
    case 'a2': return r\acct($tx->uid2, $tx->agt2);
    case 'amt1': return $tx->e1->amount;
    case 'amt2': return $tx->e2->amount;
    case 'taking': return ($tx->actorId == $tx->uid2);

    case 'otherId': return $tx->otherEntry->uid;
    case 'actorA': return r\acct($tx->actorId, $tx->actorAgentId);
    case 'actorAmount': return $tx->getActorAmount();
    case 'payerAmount': return $tx->payerEntry->amount;
    case 'otherA': return r\acct($tx->otherId, $tx->taking ? $tx->agt1 : $tx->agt2);
    
    case 'banking': return $tx->a1->isBank();
    case 'outer': return ($tx->uid1 == UID_OUTER);
    case 'toActor': return ($tx->uid2 == $tx->actorId);
    case 'toMe': return ($tx->payeeId == $myid);
    case 'byMe': return ($tx->actorId == $myid);
    case 'reversedByXid': return db\get('xid', 'tx_hdrs_all', 'reversesXid=:xid', ['xid' => $this->xid]);
    default:
      u\EXPECT(FALSE, "unexpected field '$f' requested");
    }
  }

  public function __set($name, $value) {
    u\EXPECT(FALSE, "Cannot set $name");
  }
  
  public function is($bit) {return (bool) u\getBit($this->flags, $bit);}

  private function getE($e) {return nni($this->entries, $e, NULL);}

  private function getPayerEntry() {
    foreach ($this->entries as $i => $entry) {
      if (in($entry->entryType, E_PRIMES) and $i % 2 != 0) return $entry;
    }
    return NULL;
  }

  private function getPayeeEntry() {
    foreach ($this->entries as $i => $entry) {
      if (in($entry->entryType, E_PRIMES) and $i % 2 == 0) return $entry;
    }
    return NULL;
  }

  private function getActorEntry() {
    foreach ($this->entries as $i => $entry) {
      if ($entry->uid == $this->actorId) return $entry;
    }
    return NULL;
  }

  public function getAmount($a) {
    $total = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $a->id or $entry->uid == $a->jid) $total += $entry->amount;
    }
    return $total;
  }

  public function getActorAmount() {
    $total = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $this->actorId) $total += $entry->amount;
    }
    return $total;
  }

  /**
   * Add some entries to this transaction (always in pairs or collections of pairs).
   */
  public function addEntries($entries) {
    $this->entries += array_merge($this->entries, $entries);
  }
  
  /**
   * Save this transaction in the database (header record plus all entries).
   * @return the xid of the transaction
   */
  function insert($allowModification = FALSE) {
    global $boxId;
    
    $tx = $this;
    u\setDft($tx->boxId, nn($boxId, 0));
    
    $DBTX = \db_transaction();
    if ($allowModification and $tx->xid != 0) {
      $xid = $tx->xid;
      u\EXPECT(db\updateOrInsert('tx_hdrs', just(self::TX_FIELDS, (array)$tx), 'xid'), "failure inserting tx");
    } else {
      u\EXPECT($tx->xid == 0, "We're not allowing modification of transactions.");
      $xid = db\insert('tx_hdrs', just(self::INSERT_FIELDS, (array)$tx), 'xid');
      u\EXPECT($xid, 'tx_hdrs insert failed');
    }
    u\EXPECT($xid, "Failed to insert transaction header record");

    be\insertTxes($tx->entries, $xid);
    $this->xid = $xid;
    unset($DBTX);
    return $xid;
  }

  /**
   * Return a Tx object for the given xid OR (NYI quite yet) an array of Tx objects for the given criteria.
   * @param int $xid: ID of the tx record to return an object for
   * return a Tx object, an array of such, or FALSE
   */
  public static function read($xid = '', $uids = '', $starting=NULL, $ending=NULL) {
//    u\EXPECT([$xid, $uids, $starting, $ending], 'array|int integer|empty integer|empty');

    if ($uids) {
      if (is_array($uids)) $uids = join(',', $uids);
      $users = 'uid IN ($uids)';
    } else $users = '1';
    
    $restrict = '';
    if ($xid) $restrict .= " AND xid=$xid";
    if (nn($starting)) $restrict .= " AND t.created>=$starting";
    if (nn($ending)) $restrict .= " AND t.created<=$ending";
    
    $sql = <<< EOF
      SELECT t.*, e.*
      FROM tx_hdrs t LEFT JOIN tx_entries e USING (xid)
      WHERE (t.xid IN (SELECT DISTINCT xid FROM tx_entries WHERE $users)) $restrict
      ORDER BY e.xid, e.entryType<>:E_PRIME, e.entryType<>:E_BANK, e.entryType<>:E_OUTER, e.entryType, ABS(e.id), (e.id < 0)
EOF;

    $result = db\q($sql, []);

    u\EXPECT($result, "Failure reading transactions for user(s) " . pr($uids));
    $lastXid = 0;  // no xid should ever be 0
    $txs = [];
    $entries = [];
    foreach ($result as $row) {
      $row = (array)$row;
      if ($row['xid'] != $lastXid) { // start of new transaction
        $lastXid = $row['xid'];
        if ($entries != []) { // there was a transaction in progress
          $txs[] = new Tx(just(self::TX_FIELDS, $row) + compact('entries'));
          $entries = [];
        }
      }
      $entry = new TxEntry(just(r\TxEntry::E_FIELDS, $row));
      $entries[] = $entry;
    }
    if ($entries != []) $txs[] = new Tx(just(self::TX_FIELDS, $row) + compact('entries')); // last one

    return count($txs) ? ($xid ? $txs[0] : $txs) : FALSE;
  }

  /**
   * Return the last transaction meeting the given criteria, for the given user.
   * Subsidiary transactions are ignored
   * @param array $uids: an array of uids to consider
   * @param string $where: additional criteria (defaults to 1 = any)
   * @param array $subs: optional substitutions (will be prefixed with colons)
   * @return associative array: the old transaction record (FALSE if none)
   */
  static function lastTx($uids, $where = 1, $subs = []) {
///   debug("lastTx(" . pr($uids) . ", '$where', " . pr($subs) . ")");
    u\zWhereSubs($where, $subs);
    $where = "e.uid IN (:uids) AND entryType IN (:primes) AND $where ORDER BY t.created DESC LIMIT 1";
    $xid = db\get('t.xid', 'tx_hdrs t JOIN tx_entries e USING(xid)', $where, ray('uids primes', $uids, E_PRIMES) + $subs);
    if (empty($xid)) return FALSE;
    $tx = self::read($xid);
    if (empty($tx)) return FALSE;
    return $tx;
  }

  /**
   * Format and return args for reporting a transaction (old or new) to the current account.
   * Not all returned args are used for any particular type of transaction.
   * Note that templates and tests depend on the names of some of these fields
   * @param acct $a: the account to report for (usually the current account)
   * @param int $getBalance: <report my balance>
   * @param float $shortfall: how much short my balance is, for a transaction (if any)
   * @return assoc array of args
   */
  public function reportArgs($me, $getMyBal = FALSE, $shortfall = 0) {
    global $channel;
    $tx = $this;

    $e1 = $this->payerEntry;
    $e2 = $this->payeeEntry;

    u\EXPECT(is_object($e1) and is_object($e2), 'party not an object in tx entry:' . pr($tx));
    
    $amount = ($tx->actorId == $e1->uid) ? $e1->amount : $e2->amount;
      
    $otherA = r\acct(($me->isMe($e1->uid)) ? $e2->uid : $e1->uid);
    
    $toMe = $otherA->isBank() ? ($amount < 0 xor $tx->xid < 0) : $me->isMe($e2->uid);
    
    $reverses = !empty($tx->reverses);
    $role = $toMe ? 'payee' : 'payer';
    $purpose = $toMe ? $e2->description : $e1->description;
    $tofrom = $toMe ? t('from') : t('to'); 
    $why = ray(R_WHYS)[$tx->goods];
    $balance = ($getMyBal and ($me->can(B_BUY))) ? u\fmtAmt($me->avail(FOR_GOODS)) : NULL;

    if ($amount < 0) list ($amount, $tofrom) = [-$amount, t('to')];

    $balance = ($getMyBal and $me->can(B_BUY)) ? $me->avail(FOR_GOODS) : 0;
    
    return ray('created createdDpy xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success',  // . ' role'
               $tx->created, fmtDt($tx->created), $tx->xid, $role, $why, $e1->description,
               $e2->description, $toMe, u\fmtAmt($amount), $tofrom, $balance, $otherA->id, $me->fullName,
               $otherA->fullName, u\fmtAmt($shortfall), TRUE);
  }

  /**
   * Determine whether the record can be undone by the given account.
   * @param acct $a:
   * @param assoc $subs: (RETURNED) necessary substitutions, if any, including whatever was already there
   * @return a txRet object on "no Undo", or FALSE if the current agent CAN undo it on behalf of the current account
   */
  function noUndo($a, &$subs = []) {
    if ($this->reversedByXid) return be\txRet(FALSE, 'already undone');
    if (!in($a->id, [$this->uid1, $this->uid2])) return be\txRet(FALSE, t('tx not yours'));

    $neg = ($this->amt2 > 0);
    $isToMe = ($this->uid1 == $a->id); // reversing tx is to me if I was the payer
    
    return r\txPermErr($a, $isToMe ? $this->a2 : $this->a1, $isToMe xor $neg, $neg);
  }
} // end of class tx
