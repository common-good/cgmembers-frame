<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;

require_once __DIR__ . '/txentry.class';

/**
 * @file
 * CG credit Transaction class
 *
 * Note that a transaction has at least two entries, which this class refers to
 */

class Tx {
  const REQUIRED_FIELDS = 'goods actorId flags';
  const INSERT_FIELDS = self::REQUIRED_FIELDS . ' actorAgentId channel boxId goods risk risks recursId reversesXid created cat';
  const ALLOWED_FIELDS = self::INSERT_FIELDS . ' entries xid';
  const TX_FIELDS = self::INSERT_FIELDS . ' xid';

  public $xid;
  public $type;
  public $goods;
  public $actorId;
  public $actorAgentId;
  public $flags;
  public $channel;
  public $boxId;
  public $risk;
  public $risks;
  public $recursId;
  public $reversesXid;
  public $created;
  public $cat;
  public $entries;
  
  /**
   * Instantiate (construct) a transaction record.
   * @param assoc $info: array of field values for new transaction, must include REQUIRED_FIELD entries,
   *                     but must only include ALLOWED_FIELD entries.
   */
  function __construct($info) {
    $tx = $this;
    u\vetObjectInfo($info, self::ALLOWED_FIELDS, self::REQUIRED_FIELDS, 'Tx');

    foreach (ray(self::TX_FIELDS) as $k) $tx->$k = array_key_exists($k, $info) ? $info[$k] : (in($k, 'xid flags risks channel') ? 0 : NULL);
    $tx->created = u\setDft($info['created'], now());
    $tx->entries = u\setDft($info['entries'], []);
  }

  /**
   * Return the value of the specified field that is not a simple property of the class.
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($f) {
    $tx = $this;
    global $mya;
    $myid = $mya ? $mya->id : NULL;
    
    switch ($f) {
    case 'actorEntry': return $tx->getActorEntry();
    case 'otherEntry': 
      return $tx->primeEntry1->uid == $tx->actorId ? $tx->primeEntry2 
      : ($tx->primeEntry2->uid == $tx->actorId ? $tx->primeEntry1 : NULL);
    case 'payerEntry': return $tx->getPayerEntry();
    case 'payeeEntry': return $tx->getPayeeEntry();
    case 'primeEntry1': return $tx->getE(0); // primary payer
    case 'primeEntry2': return $tx->getE(1); // primary payee
    case 'payerId': return $tx->payerEntry->uid;
    case 'payeeId': return $tx->payeeEntry->uid;
    case 'otherUid':
    case 'otherId': return $tx->otherEntry->uid;
    case 'actorA': return r\acct($tx->actorId, $tx->actorAgentId);
    case 'actorAmount': return $tx->getActorAmount();
    case 'payerAmount': return $tx->payerEntry->amount;
    case 'otherA': return r\acct($tx->otherId);
    case 'toMe': return ($tx->payeeId == $myid);
    case 'byMe': return ($tx->actorId == $myid);
    case 'reversedByXid': return db\get('xid', 'tx_hdrs_all', 'reversesXid=:xid', ['xid' => $this->xid]);
    default:
      u\EXPECT(FALSE, "unexpected field '$f' requested");
    }
  }

  public function __set($name, $value) {
    u\EXPECT(FALSE, "Cannot set $name");
  }
  
  public function is($bit) {return (bool) u\getBit($this->flags, $bit);}

  private function getE($e) {return nni($this->entries, $e, NULL);}

  private function getPayerEntry() {
    foreach ($this->entries as $i => $entry) {
      if (in($entry->entryType, [E_PRIME, E_BANK]) and $i % 2 != 0) return $entry;
    }
    return NULL;
  }

  private function getPayeeEntry() {
    foreach ($this->entries as $i => $entry) {
      if (in($entry->entryType, [E_PRIME, E_BANK]) and $i % 2 == 0) return $entry;
    }
    return NULL;
  }

  private function getActorEntry() {
    foreach ($this->entries as $i => $entry) {
      if ($entry->uid == $this->actorId) return $entry;
    }
    return NULL;
  }

  public function getAmount($a) {
    $total = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $a->id or $entry->uid == $a->jid) $total += $entry->amount;
    }
    return $total;
  }

  public function getActorAmount() {
    $total = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $this->actorId) $total += $entry->amount;
    }
    return $total;
  }

  public function getMyTid($me) {
    $myTid = 0;
    foreach ($this->entries as $entry) {
      if ($entry->uid == $me->uid or $entry->uid == $me->jid) {
        $myTid = max($myTid, $entry->acctTid);
      }
    }
    return $myTid;
  }

  /**
   * Add some entries to this transaction (always in pairs or collections of pairs).
   */
  public function addEntries($entries) {
    $this->entries += array_merge($this->entries, $entries);
  }
  
  /**
   * Save this transaction in the database (header record plus all entries).
   * @return the xid of the transaction
   */
  function insert($allowModification = FALSE) {
    $tx = $this;
    $DBTX = \db_transaction();
    if ($allowModification and $tx->xid != 0) {
      $xid = $tx->xid;
      u\EXPECT(db\updateOrInsert('tx_hdrs', just(self::TX_FIELDS, (array)$tx), 'xid'), "failure inserting tx");
    } else {
      u\EXPECT($tx->xid == 0, "We're not allowing modification of transactions.");
      $xid = db\insert('tx_hdrs', just(self::INSERT_FIELDS, (array)$tx), 'xid');
      u\EXPECT($xid, 'tx_hdrs insert failed');
    }
    u\EXPECT($xid, "Failed to insert transaction header record");

    foreach ($tx->entries as $i => $entry) {
      $tx->entries[$i]->id = $eid = $entry->insert($xid, ($i % 2) ? -$eid : 0); // eid of second entry in each pair is the inverse of its companion
      u\EXPECT($eid, "Failed to insert transaction entry");
    }
    $this->xid = $xid;
    unset($DBTX);
    return $xid;
  }

  /**
   * Return a Tx object for the given xid OR (NYI quite yet) an array of Tx objects for the given criteria.
   * @param int $xid: ID of the tx record to return an object for
   * return a Tx object, an array of such, or FALSE
   */
  public static function read($xid = '', $uids = '', $starting=NULL, $ending=NULL) {
//    u\EXPECT([$xid, $uids, $starting, $ending], 'array|int integer|empty integer|empty');

    if ($uids) {
      if (is_array($uids)) $uids = join(',', $uids);
      $users = 'uid IN ($uids)';
    } else $users = '1';
    
    $restrict = '';
    if ($xid) $restrict .= " AND xid=$xid";
    if (nn($starting)) $restrict .= " AND t.created>=$starting";
    if (nn($ending)) $restrict .= " AND t.created<=$ending";
    
    $sql = <<< EOF
      SELECT t.*, e.*
      FROM tx_hdrs t LEFT JOIN tx_entries e USING (xid)
      WHERE (t.xid IN (SELECT DISTINCT xid FROM tx_entries WHERE $users)) $restrict
      ORDER BY e.xid, e.entryType, ABS(e.id), (e.id < 0)
EOF;

    $result = db\q($sql, []);

    u\EXPECT($result, "Failure reading transactions for user(s) " . pr($uids));
    $lastXid = 0;  // no xid should ever be 0
    $txs = [];
    $entries = [];
    foreach ($result as $row) {
      $row = (array)$row;
      if ($row['xid'] != $lastXid) { // start of new transaction
        $lastXid = $row['xid'];
        if ($entries != []) { // there was a transaction in progress
          $txs[] = new Tx(just(self::TX_FIELDS, $row) + compact('entries'));
          $entries = [];
        }
      }
      $entry = new TxEntry(just(r\TxEntry::E_FIELDS, $row));
      $entries[] = $entry;
    }
    if ($entries != []) $txs[] = new Tx(just(self::TX_FIELDS, $row) + compact('entries')); // last one

    return count($txs) ? ($xid ? $txs[0] : $txs) : FALSE;
  }

  /**
   * Return the last transaction meeting the given criteria, for the given user.
   * Rebates, bonuses, and deleted transactions are ignored
   * @param array $uids: an array of uids to consider
   * @param string $where: additional criteria (defaults to 1 = any)
   * @param array $subs: optional substitutions (will be prefixed with colons)
   * @return associative array: the old transaction record (FALSE if none)
   */
  static function lastTx($uids, $where = 1, $subs = []) {
///   debug("lastTx(" . pr($uids) . ", '$where', " . pr($subs) . ")");
    if (is_array($where) and !$subs) list ($where, $subs) = [u\where($where), $where];
    $where = "e.uid IN (:uids) AND entryType=:E_PRIME AND $where ORDER BY t.created DESC LIMIT 1";
    $xid = db\get('t.xid', 'tx_hdrs t JOIN tx_entries e USING(xid)', $where, compact('uids') + $subs);
    if (empty($xid)) return FALSE;
    $tx = self::read($xid);
    if (empty($tx)) return FALSE;
    return $tx;
  }

  /**
   * Format and return args for reporting a transaction (old or new) to the current account.
   * Not all returned args are used for any particular type of transaction.
   * Note that templates and tests depend on the names of some of these fields
   * @param acct $a: the account to report for (usually the current account)
   * @param int $getBalance: 0=don't get any balances, 1=get my balance and tid, 2=get other party's balance and tid also
   * @param float $shortfall: how much short my balance is, for a transaction (if any)
   * @return assoc array of args
   */
  public function reportArgs($me, $getMyBalance = FALSE, $shortfall = 0) {
    global $channel;
    $tx = $this;

    $payerE = $this->payerEntry;
    $payeeE = $this->payeeEntry;

    u\EXPECT(is_object($payerE) and is_object($payeeE), 'party not an object in tx entry:' . pr($tx));
    
    $amount = ($tx->actorId == $payerE->uid) ? $payerE->amount : $payeeE->amount;
      
    $other = r\acct(($me->isMe($payerE->uid)) ? $payeeE->uid : $payerE->uid);
    
    $toMe = $other->isBank() ? ($amount < 0 xor $tx->xid < 0) : $me->isMe($payeeE->uid);
    
    $reverses = !empty($tx->reverses);
    $role = $toMe ? 'payee' : 'payer';
    $purpose = $toMe ? $payeeE->description : $payerE->description;
    $tid = $toMe ? $payeeE->acctTid : $payerE->acctTid;
    $tofrom = $toMe ? t('from') : t('to'); 
    $why = ray(R_WHYS)[$tx->goods];
    if ($getMyBalance and ($me->can(B_BUY))) { $balance = u\fmtAmt($me->avail(FOR_GOODS)); }
    else { $balance = NULL; }

    if ($amount < 0) {
      $amount = 0-$amount;
      $tofrom = t('to');
      /* $did = $toMe ? (($this->goods == FOR_GOODS) ? t('refunded') : t('credited')) : t('charged'); */
    } else {
      /* $did = $toMe ? ($reverses ? t('re-charged') : t('charged')) */
      /*   : (($this->channel == TX_APP and $me->co) ? t('credited') : t('paid')); */
    }

    $balance = ($getMyBalance and $me->can(B_BUY)) ? $me->avail(FOR_GOODS) : 0;
    
    return ray('created created0 xid role why payerPurpose payeePurpose toMe amount tofrom balance otherUid myName otherName short success',  // . ' role'
               u\fmtDate($tx->created), $tx->created, $tx->xid, $role, $why, $payerE->description,
               $payeeE->description, $toMe, u\fmtAmt($amount), $tofrom, $balance, $other->id, $me->fullName,
               $other->fullName, u\fmtAmt($shortfall), TRUE);
  }

  /**
   * Determine whether the record can be undone
   * @param assoc $subs: (RETURNED) necessary substitutions, if any, including whatever was already there
   * @return a txRet object on "no Undo", or FALSE if the current agent CAN undo it on behalf of the current account
   */
  function noUndo(&$subs = []) {
    if (db\exists('tx_hdrs', 'reversesXid=:xid', ['xid' => $this->xid])) return be\txRet(FALSE, 'already undone');

    list ($a1, $a2) = u\order($this->toMe, $this->actorA, $this->otherA); // second agent's permissions are irrelevant?
    if ($zErr = r\txPermErr($a1, $a2, $this->toMe, $this->actorEntry->amount < 0)) return $zErr;

    return FALSE;
  }
} // end of class tx
