<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;
use CG\Web as w;
use CG\Admin as a;
use CG\Testing as t;

/**
 * @file
 * %PROJECT Account class
 */

define('SSN_TIMEOUT_MSG', t('No data returned from ssnLookup'));
 
class Acct {
  public $id; // the account's record id
  public $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  public $qo; // qid object
  
  private static $perms = []; // permissions for all acct objects, indexed by id and agent
  private static $rs = []; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * @param mixed $info (either assoc or array):
   *   (1) an assoc: initial field values for the account, to be created in the database, including at least one of these:
   *     'uid' the record id
   *     'phone' is contact phone (in standard +ddddddddddd format) OR
   *     'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *     'email' is email address
   *     (This function assumes that the field values not sufficient to identify an existing user)
   *   (2) a flat array of user table IDs: [uid, agent] where uid is the main account and agent is the agent's id
   */
  function __construct($info = []) {
    $a = $this;
    if (!is_numeric(key($info))) { // u\isAssoc($info)) { // specifying field values
      $a->createNew($info); // create new db record
    } else { list($a->id, $a->agentId) = $info; } // called from r\acct()
    $a->qo = r\qo($a->id, $a->proSe ? '' : $a->agentId);
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account (only fullName is required)
   */
  private function createNew($info) {
    global $mya;
    $a = $this;
    extract($info);

    extract(just('fullName flags state zip created number uid region postalAddr', $info,
      [NULL, 0, 0, NULL, now(), NULL, NULL, NULL, NULL]));
    u\setDft($legalName, $fullName);
    u\setDft($email, mb_strtolower(u\randomString(10, 'word')) . '@' . EMAILX);
    u\setDft($community, r\communityId($zip));
    u\setDft($login, $created);
    u\setDft($access, $login);
    u\setDft($name, r\uniqueName($fullName, $info));
    u\setDft($country, R_COUNTRY_ID);

    if (isset($phone)) $phone = u\fmtPhone($phone, '+n');
    if (!is_numeric($state)) $state = r\stateNum($state); // allow US state abbreviations
    $co = ($flags & u\bit(B_CO));
    
    if (empty($region)) $region = empty($zip) ? -r\uidRegion($community) : -r\region($country, $state, $zip);
    $record = empty($uid) ? compact('name') : compact('uid', 'name');

    $DBTX = db_transaction();
    $uid = r\regionalInsert('users', 'uid', $record, $region); // negative region to create a community, else regular
    u\EXPECT(!empty($uid), 'empty regionalinsert');
    $a->reread(); // set all real fields
    list ($a->id, $a->agentId) = array($uid, $mya ? $mya->agentId : $uid); // finish creating the object

    u\setDft($cardCode, r\cardCode());
    u\setDft($emailCode, r\cardCode());
    u\setDft($notices, $uid < 0 ? NOTICE_DFTS_CTTY : NOTICE_DFTS);

    foreach (ray('number region') as $k) unset($info[$k]);
    foreach (ray('phone email pass fullName legalName flags state country community created login access emailCode cardCode notices') as $k) if (isset($$k)) $info[$k] = $$k; // things we may have added or changed

    $a->update($info); // this is a lot easier to do after saving the record
    if (!$a->member) $a->setTask($co ? 'co' : 'person');
    
    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   * @param id/qid $id: the account's record id or qid (DEFAULT to myid)
   * @param id/qid $agent: the agent's record id or qid (DEFAULT to same as $id)
   * @param bool $test: <this is only a test, do not die on error>
   * @return [$id, $agent] where id and agent are actual record IDs
   */
  public static function viable($id00, $agent0='', $test = TRUE) {
    if (is_numeric($id00) and (is_numeric($agent0) or empty($agent0))) {
      list ($id, $agent) = [$id00, $agent0 ?: $id00];
    } else {
      $id0 = $id00;
      if (strpos($id0, AGT_MARK)) list ($id0, $agentCode) = explode(AGT_MARK, $id0); // new company qid format

      if (u\EXPECT(compact(ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
      if (!$id0) return $test ? FALSE : u\FAIL(t('null uid in new r\Acct()'));
      list ($id, $agent) = u\isZid($id0) ? [$id0, $agent0 ?: $id0] : r\qo($id00, $agent0)->ia; // handle

      if (u\isQid($agent0)) {
        list ($agent, $zot) = r\qo($agent0)->ia;
        if ($agent != $zot) return $test ? FALSE : u\FAIL(t('agent agent not allowed'));
      }

      if (isset($agentCode)) $agent = r\qo($id0 . AGT_MARK . $agentCode)->agent; // new company qid format
    }
    
    if (!$id or !$agent) return $test ? FALSE : u\FAIL("Missing acct property: [$id, $agent]");
    
    foreach ($id == $agent ? [$id] : [$id, $agent] as $uid) {
//      if (!db\exists('users', compact('uid'))) {
      $rec = (array) self::getRecord($uid, TRUE); // read the record into cache
      if (!nni($rec, 'uid')) return $test ? FALSE : u\FAIL(t('That account does not exist.'));
    }

    return [$id, $agent];
  }
  
  private static function getRecord($uid, $reread = FALSE) {
///       print_r("getRecord($uid, $reread)");
    if (nni(self::$rs, $uid) and !$reread) return self::$rs[$uid];
    if (!$row = db\get('*', 'users', compact('uid'))) { // no such record here
      if (TRUE) return FALSE; // not foreign either
      // contact other server here, for a subset of the record
    }
    
    return self::$rs[$uid] = (object) $row;
  }

  /**
   * Read in the account record, if we haven't yet.
   * This function should be called before any reference to self::$rs[$this->id] (except in contructor).
   * @param bool $force: reread even if we already have an account record (used only externally)
   */
  public function reread($force = FALSE) {
    if (!nni(self::$rs, $this->id) or $force) self::getRecord($this->id, TRUE);
  }
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Many of these fields are slightly tweaked fields from the users table (for example, unserialized or decrypted).
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($field) {
    global $mya;
    $a = $this; $uid = $a->id;
    $uidSub = compact('uid');
    $a->reread(); // make sure record has been read in

    if (u\starts($field, 'j_')) { // concatenate joint fields
      $field = substr($field, 2);
      return $a->o($field) . ($a->jid ? ' & ' . $a->jA->o($field) : '');
    }

    if (u\starts($field, 'o_')) { // ignore joinedness of the account ("own" account)
      $field = substr($field, 2);
    } elseif ($field != 'balance') { // don't add together in a joint account, even though it's a joint field (same in both)
      if (in($field, JOINT_FLDS) and $a->jid) return round(($a->o($field) ?: 0) + ($a->jA->o($field) ?: 0), 2); // sum joint fields
      if (in($field, MASTER_FLDS) and $a->slave) return $a->jA->o($field); // master only
    }

    // From here down, everything should be for "own" account
    $nick = $a->getNick($field); // modifies $field and sets nick to 'can' for flag bits
    if ($nick == 'can') return $a->can(u\consta('b', $field));
    if ($nick == 'rel') return $a->proSe ? NULL : $a->relFld($field);
    if ($nick == 'coy') return $a->co ? $a->coFld($field) : NULL;
    if ($nick == 'cof') return $a->co ? $a->coCan($field) : NULL;
    if ($nick == 'adm') return $a->admin ? $a->adminCan($field) : FALSE;
    if ($nick == 'ctt') return $field == 'a' ? r\acct($a->community) : $a->cttyA->can(u\consta('b', $field)); // ctty bit

    if ($obj = nni(self::$rs, $a->id) and property_exists($obj, $field)) { // actual database field?
      $res = $obj->$field; // get the raw data, then handle any encryption
      /// Not currently used    if ($nick == 'raw') return $res;
      if ($field == 'balance') return db\get('balance', 'users', $uidSub); // make sure this field is always au courant
      if ($field == 'email') return u\decryIf('P', nn($obj->email));
      if ($field == 'phone') return u\decryIf('P', nn($obj->phone));
      if (in($field, 'data secure vsecure') and !is_array($res)) { // aggregated field not yet decrypted and arrayed
        if (!$res) return [];
        if ($field != 'data') $res = u\decry('S', $res);
        return (self::$rs[$a->id]->$field = unserialize($res));
      }
      return $res; // normal field (no encryption)
    }
    
    switch ($field) { // handle pseudo-fields (every case returns)
      case 'mainQid': return $a->qo->mainQid;
      case 'phoneDash': return u\fmtPhone($a->phone, '-');
      case 'st': return r\realState($a->state, $a->country);
      case 'mainA': return r\acct($a->id);
      case 'agentA': return r\acct($a->agentId);
      case 'proSe': return ($a->id == $a->agentId);
      case 'qid': return $a->qo->qid;
      case 'uids': return $a->jid != 0 ? [$a->id, $a->jid] : [$a->id];
      case 'adminCans': return db\get('can', 'admins', $uidSub);
      case 'bestName': return (in($a->id, BUCKET_UIDS) and $a->id != CGID) ? $a->name : str_replace(PROJECT . t(' FBO '), '', $a->shortName ?: $a->fullName);
      case 'isCtty': return ($a->id < 0); // or ($a->id == $a->community); (regions are communities too)
      case 'isRegion': return (substr($a->name, -1, 1) == '.');
      case 'region': return r\uidRegion($a->id);
      case 'regionA': return r\acct($a->region);
      case 'regionName': return ($regionA = $a->regionA) ? $regionA->fullName : (PROJECT . ' ' . db\get('name', 'r_regions r INNER JOIN r_states s ON s.abbreviation=r.st', 's.country_id=:US_COUNTRY_ID AND r.region=:reg', ['reg' => $a->qo->region]));
      case 'url': return ($a->isRegion ? '' : strtr($a->fullName, [PROJECT=>'', ' '=>'']) . $a->st . '.') . CG_DOMAIN; // applies only to communities (->cttyUrl)
      case 'lastTx': return $a->lastTx();
      case 'lastTxDt': return ($tx = $a->lastTx) ? fmtDt($tx->created, 'yyyy-MM-dd') : FALSE;
      case 'achName': return str_replace('_', ' ', ($a->sponsored and !$a->ourOwn) ? $a->fullName : $a->legalName); // for ACHs, including u\parseName of names like Jay di_Fiori
      // NOTE: when money comes into a sponsored account, the account belongs to CG (legalName). When money goes out, the account belongs to the sponsored entity (fullName).
      case 'trustCook': return "trust-$a->mainQid"; // cookie name of device trust
      case 'owns': return !$a->risk('rents');
      case 'creditLine': return -$a->floor;
      case 'hasFid': return $a->hasVSecure('federalId');
      case 'hasAltId': return $a->hasVSecure('altId');
      case 'hasId': return ($a->hasFid or $a->hasAltId);
      case 'hasDob': return $a->hasVSecure('dob');
      case 'closed': return ($a->activated and !$a->ok); // data[newAccount] has new qid, if any
      case 'hasBank': return $a->hasVSecure('bankAccount');
      case 'lowSecurity': return u\n2ai(substr($a->created, -5, 5), 3); // result is 3 chars long
      case 'inviteCode': return $a->mainQid . $a->lowSecurity;
      case 'isCanonic': return ($a->id >= 0 and $a->id <= UID_CANON9);
      case 'slave': return ($jid = $a->jid and $jid < $a->id); // slave in a joint account
      case 'jA': return $a->jid ? r\acct($a->jid) : NULL;
      case 'masterA': return $a->slave ? $a->jA : $a;
      case 'helperA': return $a->helper ? r\acct($a->helper) : '';
      case 'usa': return ($a->country == US_COUNTRY_ID);
      case 'card': return ($a->ok and $a->stepsDone('card'));
      case 'vote': return ($a->ok and $a->stepsDone('vote'));
      
      case 'foody': return db\get(':U_FOODY', 'users u', $uidSub);
      case 'iclub': return ($a->id < 0 or strhas($a->fullName, t('Investment Club')));
      case 'iclubId': return db\get('clubid', 'r_stakes', $uidSub); // member's investment club ID (one of many) DEPRECATED
      case 'trialco': return ($a->co and $a->depends);
      case 'seedpacker': return ($a->community == r\serverUid());
      case 'prefsSet': return !is_null($a->o_minimum); // preferences have been set at least once
      case 'hasCustomers': return db\exists('u_relations', 'main=:id AND :IS_CUSTOMER', ['id' => $a->id]);
      case 'bankInfo': return ($routing = substr($a->bankAccount, 4, 9)) ? db\get('*', 'r_banks', 'route=:routing', compact('routing')) : NULL;
      case 'shouter': return db\exists('u_shout', $uidSub);
      case 'tempPhotoFilename': return r\pic("$a->mainQid.jpg");
      case 'ssnErr': return is_array($a->ssnData) ? nni($a->ssnData, SSN_ERR_INDEX) : FALSE;
      case 'hasPhoto': return db\exists('u_photo', $uidSub);
      case 'photo': return ($res = db\get('photo', 'u_photo', $uidSub)) ? u\decry('H', $res) : '';
      case 'thumb': return db\get('thumb', 'u_photo', $uidSub) ?: '';
      case 'hasLogo': return file_exists(LOGO_DIR . '/' . $a->mainQid);
      case 'signedIn': return isset($mya); // use only in r\access
      case 'investor': return ($a->iclub or db\exists('r_stakes', $uidSub));
      case 'emailCoded': return urlencode(u\cry('P', $a->email));
      case 'changes':
        $chFlds = 'oldValue,newValue';
        foreach ($rows = db\rows($chFlds, 'r_changes', $uidSub) as $i => $row) {
          foreach (ray($chFlds) as $k) if ($type = u\crypted($row->$k)) $rows[$i]->$k = u\decry($type, $row->$k);
        }
        return $rows;
      default: return $a->getSpecial($field); // member of an aggregate field: set up caches and get value
    }
  }

  /**
   * Return the 3-character field prefix, if any, and remove it from the field name.
   * The character following the prefix must be uppercase.
   * @param string $field: the original virtual property
   * @param string $field (RETURNED): a field or flag name in some related table, if such exists; otherwise unchanged
   * @return: the 3-character prefix that indicates where to find the wanted data (FALSE if none)
   */
  private function getNick(&$field) {
    $nick = substr($field, 0, 3); // possibly meaningful prefix (ctt if the prefix is ctty)
    if (preg_match('/^(can|raw|rel|coy|cof|ctty|adm)[A-Z]/', $field)) {
      $field = lcfirst(substr($field, $nick == 'ctt' ? 4 : 3));
      return $nick;
    }
    
    if (in($field, REL_FLDS . ' ' . REL_FLAGS)) return 'rel';
    if (in($field, CO_FLDS)) return 'coy';
    if (in($field, B_LIST . ' ' . B_CTTY_BITS)) return 'can';
    if (in($field, CO_FLAGS)) return 'cof';
    // admin permission fields must include the adm prefix
    return FALSE;
  }

  /**
   * Cache the set of special fields of which the given field is a member.
   * @param mixed $field: name of a field within an aggregate field (data/secure/vsecure)
   * @return the field value
   * @throw warning if the field does not exist
   */
  private function getSpecial($field) {
    global $sceneTest;
    $a = $this;
    foreach (ray('data secure vsecure') as $k) {
      if ($a->special($field, strtoupper($k))) {
        $set = $a->$k ?: []; // special field $k gets cached by call to $a->$k
        $result = nni($set, $field);
        if ($k == 'vsecure') {
          if (u\crypted('V', $result)) {
            if (t\deCryVok()) return u\decry('V', $result);
            u\EXPECT(!$a->ok and !$a->activated, t('non-admin trying to deCry %field', compact('field'))); // don't try to decrypt something we can't (admin stands in for super, in tests)
          }
          return $result;
        } else return $result;
      }
    }
    
    trigger_error(t('Account pseudo-field "%field" is undefined.', compact('field')), E_USER_WARNING);
    return NULL;
  }
  
  /**
   * Say whether the given field(s) is/are the specified kind of special.
   * @param mixed $fields: array or space-delimited list of fields (one or more)
   * @param string $specialType: name of space-delimited list of special fields of a certain type.
   * @return <at least one of $fields is in the $specialType list>
   */
  private function special($fields, $specialType) {
    $specials = constant("{$specialType}_FLDS");
    return is_array($fields) ? (bool) array_intersect($fields, ray($specials))
      : (strhas($fields, ' ') ? (bool) array_intersect(ray($fields), ray($specials))
        : u\inList($fields, $specials)); // be efficient, if just one field
  }

  /**
   * Return the value of a company field.
   */
  private function coFld($k) {
    $a = $this;
    if (!$a->co) return NULL;
    $subs = ray('uid', $a->id);
    if (!$info = db\get('*', 'u_company', 'uid=:uid', $subs)) {
      db\insert('u_company', $subs, 'uid');
      return nni($subs, $k); // NULL unless $k is 'uid'
    } else return $info[$k];
  }
  
  /**
   * Set one or more company fields
   */
  private function setCo($info) {db\updateOrInsert('u_company', $info + ['uid' => $this->id], 'uid');}
  
  /**
   * Return the value of a relationship field for this compound account.
   */
  function relFld($k = 'reid') {
    $a = $this;
    if ($a->proSe) return NULL;
    if (in($k, REL_FLAGS)) {
      $flags = r\relation('flags', $a->id, $a->agentId);
      return u\getBit($flags, u\consta('b', $k));
    } else return r\relation($k, $a->id, $a->agentId); // not $a->qid because it depends on otherNum
  }
  
  /**
   * Set a relation field.
   * Current account is expected to be r\acct($main, $other).
   * @param assoc $info: fields and values to change (if relations record does not exist, create it)
   *   $info may include bit names for the flags field
   */
  public function setRel($info) {
    $a = $this;
    u\EXPECT(!$a->proSe, 'setting relation on proSe');
    if (!is_array($info)) $info = rayy(func_get_args());

    if ($set = just(REL_FLAGS, $info)) {
      $flags = $a->relFld('flags') + 0;
      foreach ($set as $k => $v) {
        u\setBit($flags, $k, $v);
        unset($info[$k]);
      }
      $info += compact('flags');
    }
    if ($reid = $a->relFld('reid')) {
      return db\updateOrInsert('u_relations', $info + compact('reid'), 'reid');
    } else $a->newRelation($info + ray('other', $a->agentId));
  }      
  
  /**
   * Return major donor information.
   */
  public function majorInfo() {
    $a = $this;
    $uids = $a->uids;
    foreach (ray($flds = 'co fullName phone email city st') as $k) $$k = $a->$k;
    $phone = u\fmtPhone($phone, '-');
    $co = $co ? 'co' : ' ';
    $maxGift = db\max('amt', 'txs', 'uid1 IN (:uids) AND uid2=:CGID', compact('uids')) ?: ''; // was :IS_GIFT but old recurring donations don't have that
    $pastYear = db\sum('amt', 'txs', 'uid1 IN (:uids) AND uid2 IN :BUCKET_UIDS AND created>:yearAgo', ray('uids yearAgo', $uids, strtotime('-1 year'))) ?: '';
    $months = (now() - $a->created) / MONTH_SECS;
    $investor = $a->iclubq;
    $invitees = db\count('r_invites', 'inviter IN (:uids)', compact('uids')) ?: '';
    $avgBalance = nni(r\averageBalance($a->id), 0);

    $score = 0;
    $ws = ray('maxGift:20, pastYear:10, months:10, investor:20, invitees:5, avgBalance:7');
    foreach ($ws as $k => $v) if ($$k > 0) $score += (in($k, 'investor invitees') ? $$k : log10($$k)) * $v;
    if ($investor) $investor = $a->iintent;
    $ask = round(max(2 * $maxGift, $pastYear, $months, $investor / 10, $invitees, $avgBalance) + 9.99, -1);
    if ($ask > 1000) $ask = round($ask, -2);
    
    return compact(ray("score ask $flds " . join(' ', array_keys($ws))));
  }

  /**
   * Set the company categories.
   */
  function setCategories($cats) {
    $a = $this;
    $DBTX = db_transaction();
    db\del('r_user_industries', 'uid=:id', ['id'=>$a->id]);  // out with the old
    foreach ($cats as $iid) db\insert('r_user_industries', ray('uid iid', $a->id, $iid)); // in with the new
    unset($DBTX); // commit
  }  
  
  /**
   * Return (and maybe set) the box record ID for this account
   * @param int $code: device identifier
   * @param string $version: app version (web version is not used here)
   */
  public function boxId($code = NULL, $version = NULL) {
    global $channel, $boxId; // store boxId for Tx::insert and r\ipOk()
    $a = $this; $uid = $a->id;
    
    $web = ($channel == TX_WEB);
    $created = $access = now();
    if ($boxId) return;
    
    if ($web) { // web channel -- get box code from cookie
      u\EXPECT(!$code, t('bad web channel call to Acct::boxId'));
      $cookid = "box-$a->mainQid";
      $code = r\cook($cookid);
    } elseif (!$code) return; // app makes its own code

    if ($code = mb_substr($code ?: '', 0, DEVICE_MAXLEN)) {
      $boxId = $id = db\get('id', 'r_boxes', compact(ray('uid code')));
      if ($web and $a->admin and !$a->proSe and !r\relation(1, $uid, $a->agentId)) return; // don't record the accounts admins visit
    } else $code = u\code();

    if (!$boxId) $boxnum = (db\get('MAX(boxnum)', 'r_boxes', compact('uid')) ?: 0) + 1;

    $info = compact(ray('access version ' . ($boxId ? 'id' : 'uid code boxnum created channel')));
    $newBoxId = db\updateOrInsert('r_boxes', $info, 'id'); // update version, channel, date
    if (!$boxId) $boxId = $newBoxId;
    if ($web) r\setCook($cookid, $code);
  }
  
  /**
   * See if the intended recipient (or any agent with manager permission) has signed in on this machine.
   * @param string $qid: the intended recipient's qid
   * @return <the intended recipient has signed in on this machine>
   */
  public function itsMyBox($qid) {
    if (!$a = r\acct($qid)) return FALSE;
    $uids = array_merge($a->uids, db\col('other', 'u_relations', 'main IN :uids AND permission>=:B_RELATED+:B_MANAGE', ray('uids', $a->uids)));
    
    foreach ($uids as $uid) {
      $qid = r\qid($uid);
      $cookieId = "box-$qid";
      if ($code = r\cook($cookieId) and $access = db\get('access', 'r_boxes', compact(ray('uid code')))) return TRUE;
    }
    return FALSE;
  }

  /**
   * Return a printable (scrambled) invitation card code or gift coupon code 
   * @param int $iCode: sequence number (0 to 35^3-1)
   * @see r\iCardAcct()
   */
  public function iCardCode($iCode = 0) {
    $a = $this;
    list ($region, $tail) = $a->qo->parse();

    $b = u\lpad(decbin(u\a2n($region)), ILEN_REGION);
    $b .= u\lpad(decbin(u\a2n($tail)), ILEN_TAIL);
    $b .= u\lpad(decbin(u\ai2n($a->lowSecurity)), ILEN_SECURITY);
    $b = u\rotateBits($b, ($iCode + 1) * (bindec(substr(R_INVITE_KEY, 0, 31)) % strlen($b)));
    $b = u\xorBits($b, substr(R_INVITE_KEY, -strlen($b)));
    return u\n2ai(bindec(substr($b, 0, ILEN_DIV)), 5) . u\n2ai(bindec(substr($b, ILEN_DIV)), 5) . u\n2ai($iCode, -1);
  }

  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return (all raw fields, if empty)
   * @param bool $own: <return just the account's own field values, even if it is a joint account> (always true if $just == '')
   * Note: the returned object does not include uid -- haven't figured out why.
   */
  public function account($just = '', $own = TRUE) {
    $a = $this;
    $a->reread(); // make sure we have read the record from the db
    if (!$just) return nni(self::$rs, $a->id);

    foreach (ray($just) as $k) $res[$k] = $own ? $a->o($k) : $a->$k;
    return (object) $res;
  }

  public static function _clear() {self::$perms = self::$rs = [];}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    u\EXPECT($region <= 0, 'non-negative region in nextId');
    return r\newUid(-($region ?: r\serverUid()));
  }
  
  /**
   * Update the saved record in the database with the given data. For joint accounts, update partner too.
   * Call by:
   *   update($info); OR
   *   update($fields, $value1, ...)
   * @param assoc $info: data to update
   * @param string $fields: space-delimited list of field names
   * @param mixed $value1 (etc): new values for those fields
   * @return: TRUE if update succeeds, FALSE if update fails
   */
  public function update($info) {
    $a = $this;
    if (!is_array($info)) $info = rayy(func_get_args());
    
    u\EXPECT(!isset($info['savings']), 'archaic savings field');
    if ($a->jid and $jInfo = just(MASTER_FLDS, $info)) {
      list ($a2, $a1) = u\order($a->slave, $a, $a->jA); // set $a1 master, $a2 slave

      $jInfo2 = array_fill_keys(array_keys($jInfo), 0);
      unset($jInfo2['achMin']); // no change to slave achMin
      $a2->update1($jInfo2);
      $a1->update1($jInfo);
      if (!$info = justNOT(MASTER_FLDS, $info)) return TRUE; // fall through if something else to update
    }
    return $a->update1($info);
  }

  /**
   * Update the account record in the database (with no special treatment of joint accounts).
   */
  public function update1($info) { // public only for testing
    $a = $this;

    if (!is_array($info)) $info = rayy(func_get_args());
    if ($bits = just(B_LIST, $info)) {
      $a->setBit($bits);
      $info = justNOT(B_LIST, $info);
    }
    
    foreach (just(REL_FLDS . ' ' . REL_FLAGS, $info) as $k => $v) {$a->setRel($k, $v); unset($info[$k]);}

    if ($coFlds = just(CO_FLDS, $info)) {$a->setCo($coFlds); $info = justNOT(CO_FLDS, $info);}

    if ($a->ok or $a->activated or nni($info, 'altId')) $a->recordChanges($info); // record changes if member is (or was) active or verifying ID (so we have a record of who verified it)
    foreach (just('hasBank', $info) as $k => $v) {$a->setRisk($k, $v); unset($info[$k]);}

    foreach (ray('photo thumb') as $k) if (isset($info[$k])) $a->updatePhoto($info, $k);
    foreach (ray(PSECURE_FLDS) as $k) if (isset($info[$k])) $info[$k] = u\cry('P', $info[$k]);
    if (isset($info['pass']) and $info['pass'] !== '') $info['pass'] = r\passHash($info['pass']);
    if (isset($info['dob']) and !$a->co) { // use new dob to adjust yob and underage flag
      $dob = $info['dob'] ?: ($a->yob ? strtotime("$a->yob-12-31 11:59:59pm") : ($a->created ?: now()));
      if (!isset($info['yob'])) $a->update('yob', $dob ? date('Y', $dob) : ''); // remember birth year for demographics
      $a->setBIT(B_UNDERAGE, now() - $dob < MATURITY * YEAR_SECS);
    }
    u\preray($info, self::$rs[$a->id]); // cache the new field values (before doing special fields)
    
    foreach (ray('data secure vsecure') as $special) {
      if (isset($info[$special])) {
        $sFlds = $info[$special]; // can be '' for no data
      } elseif ($sFlds = just(constant(strtoupper($special) . '_FLDS'), $info)) {
        $sFlds += $a->$special; // replace existing values with update info
      } else continue;

      if ($special == 'vsecure' and is_array($sFlds) and $sFlds) {
        if ($a->activated) foreach ($sFlds as $k => $v) {
          if ($v !== '' and !u\crypted('V', $v)) $sFlds[$k] = u\cry('V', $v); // hyper-encrypt when activated (when auto-access to EIN no longer needed). This and recordChanges are the ONLY places we do u\cry('V', ) !! ($v !== '' is for deleting a vsecure value, such as bankAccount, without being an admin)
        }
        if (rayhas($sFlds, 'bankAccount')) $a->setRisk('hasBank', (bool) $sFlds['bankAccount']);
      }
      self::$rs[$a->id]->$special = $sFlds;
      $sFlds = serialize($sFlds);
      $info[$special] = ($special == 'data' or !$sFlds) ? $sFlds : u\cry('S', $sFlds);
    }
    $info = justNOT(SECURE_FLDS . ' ' . VSECURE_FLDS . ' ' . DATA_FLDS, $info); // don't pass these
    if (count($info) == 1 and nni($info, 'uid') == $a->id) return TRUE; // nothing left to do
    $res = $info ? db\update('users', $info + ['uid' => $a->id], 'uid') : TRUE;
    return $res;
  }

  /**
   * Set photo or thumb.
   */
  public function updatePhoto(&$info, $k) {
    $a = $this;
    $data = $info[$k];
    $isThumb = ($k == 'thumb');
    if ($data or $isThumb) { // setting
      db\updateOrInsert('u_photo', ['uid' => $a->id, $k => $isThumb ? $data : u\cry('H', $data)], 'uid');
      if (!$isThumb and !test()) { // always create a new thumb when we create or change the photo
        $factor = ($a->co ? 2 : 1) * THUMB_FACTOR;
        list ($w, $h) = $a->co ? CO_ASPECT : FACE_ASPECT;
        $img = u\alterImg(imagecreatefromstring($data), $w * $factor, $h * $factor);
        $thumbInfo['thumb'] = u\img2string($img, $a->co ? 100 : 50);
        $a->updatePhoto($thumbInfo, 'thumb');
      }
    } else {db\del('u_photo', 'uid', $a->id);} // delete record if deleting photo
    unset($info[$k]);
  }

  /**
   * Record memorable changes being made to an account record.
   * @param assoc $info: all changes being made
   */
  private function recordChanges($info) {
    global $mya;
    $a = $this;

    $newChanges = justNOT(R_HIDE_CHANGES, $info); // see if there are any changes to remember
    foreach ($newChanges as $k => $v) {
      $ak = (in($k, VSECURE_FLDS) and !$a->admV) ? t('(encrypted)') : $a->$k;
      if ($v == $ak or (is_numeric($v) and is_numeric($ak) and $v + 0 == $ak + 0)) continue; // don't record if no change

      $oldValue = $a->cryIf($k, is_array($ak) ? serialize($ak) : ('' . $ak), TRUE);
      $newValue = $a->cryIf($k, is_array($v) ? serialize($v) : '' . $v);
      $record = ray('uid created field oldValue newValue changedBy', $a->uid, now(), $k, $oldValue, $newValue, $mya ? $mya->agentId : 0);
      db\insert('r_changes', $record); // add a r_changes record for each changed field
    }
  }
  
  /**
   * Encrypt if appropriate
   */
  private function cryIf($k, $v, $old = FALSE) {
    $a = $this;
    foreach (ray('psecure vsecure secure') as $secure) {
      list ($type, $flds) = [ucfirst($secure[0]), constant(strtoupper($secure) . '_FLDS')];
      if (in($k, $flds)) {
        if ($old and $type == 'V') $v = nni($a->vsecure, $k); // special case for possibly already-encrypted, inaccessible vsecure value
        return u\crypted($type, $v) ? $v : u\cry($type, $v);
      }
    }
    return $v;
  }
    
  /**
   * Create a new relationship record for the current account (as "main") relating to some agent.
   * NOTE: Assume no other company agent for this company is trying to create a relation at the same time.
   * @param assoc $info: field values
   * @return: the record ID of the new relationship record
   */
  function newRelation($info) {
    u\EXPECT($info['other'] or nni($info, 'data'), 'missing other in new relation'); // placeholder for "other" ok if there's data
    foreach (ray(REL_FLAGS) as $k) if (array_key_exists($k, $info)) { // array_key_exists not nn or isset (might be NULL)
      u\setBit($info['flags'], $k, $info[$k]);
      unset($info[$k]);
    }
    $info['created'] = now();
    return r\regionalInsert('u_relations', 'reid', $info + ['main' => $this->id], -$this->region);
  }

  /**
   * Create an agent number for the account's relation, if it's a relational account and doesn't have one yet.
   */
  public function setAgentNum() {
    $a = $this;
    if ($a->proSe or r\qo($a->qid)->agentCode) return;
    $otherNum = db\max('otherNum', 'u_relations', 'main=:main', ['main' => $a->id]) + 1;
    $a->setRel(compact('otherNum'));
    return $otherNum;
  }

  /**
   * Say whether the wanted transaction proof is really wrong, not just a delayed transaction with a cardcode that got changed.
   * @param string $proof: tx proof supplied by the app
   * @param string $wanted: proof we expected
   * @param int $created: transaction creation date/time
   * @return <the proof is really wrong>
   */
  public function badOldProof($proof, $wanted, $created) {
    $a = $this;
    $codeName = $a->proSe ? 'cardCode' : 'cardCode2';
    $code = $a->agentA->$codeName;
    //    $changes = $a->agentA->changes;
    $changes = db\rows('*', 'r_changes', 'uid=:id AND field=:fld AND created>:dt', ray('id fld dt', $a->agentId, $codeName,$created));

    foreach ($changes as $ch) if (u\hash(str_replace($code, u\decry('S', $ch->oldValue), $wanted)) == $proof) return false;

    return true;
  }

  /**
   * Return the account's name and qid, with a link to a fuller description.
   */
  public function linkedDesc() {
    global $base_url;
    $qid = "<a href=\"$base_url/change-account/acct=$this->mainQid\">$this->mainQid</a>";
    return "$this->fullName ($qid)";
  }
  
  /**
   * Set the bit in the given integer bit collection field to the given value.
   * If the requested bit is too high, "2" (or more) gets appended to the collection name
   * @param int $bit: number of bit to set (0 - 62)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   * @see also self::can()
   */
  public function setBit($bit, $on = TRUE, $field = 'flags') {
    $a = $this;
    
    list ($bits, $ons) = is_array($bit) ? [array_keys($bit), array_values($bit)] : [[$bit], [$on]];

    $n = $a->$field ?: 0;
    foreach ($bits as $i => $bit) {
      if ($field == 'flags' and !is_numeric($bit)) $bit = u\consta('b', $bit);
      $on = $ons[$i];
      if ($bit > B_MAX) $field .= 1 + floor($bit / (B_MAX + 1));
      u\setBit($n, $bit, $on);
      if ($field == 'flags' and nn(self::$perms['id'][$a->agentId])) {
        self::$perms['id'][$a->agentId][$bit] = $on;
      } // else can gets refreshed automatically next time can() is called
    }
    return $a->update($field, $n);
  }

  /**
   * Return the amount not available, including draws from related accounts, depending on the purpose.
   * If there are fees for drawing from a related account, they are added to the amount needed.
   * If the account has permission to cash out while serving as an ATM their rewards amount will not limit them.
   * @param int $goods: (does not default, to make sure we know what we're doing)
   *   FOR_GOODS or FOR_NONGOODS: the amount of credit available for a purchase 
   *     (including credit lines)
   *   FOR_USD: the amount of credit available to trade for cash or US Dollars
   *     (not including credit lines and rewards)
   * @param float $need: the amount needed
   * @param bool $get: if true then draw from other accounts as needed, then say whether there is enough
   *                   if false (the default) just check and say whether we could get enough
   * @param acct $actor: account of the individual or company initiating the transaction
   * @return how much short this account is, of what's needed
   */
  public function shortfall($goods, $need = 0, $get = FALSE, $actor = NULL) {
    global $channel;
    $a = $this; $uid = $a->id;

    if ($a->id < 0 or $a->isCanonic) return 0; // communities and structural accounts are never short

    if ($a->co and COMPANY_FREEZE and $a->eq($actor) and $a->coCan(CO_ATM) and $goods == FOR_USD) { $goods = FOR_GOODS; }
    $avail = $a->avail($goods);
    if ($avail >= $need) return 0; // plenty without drawing from other accounts

    $avail += $get
    ? $a->draw(($a->refill ? $a->minimum : 0) + $need - $a->balance)
    : $a->canDraw();

    return max(0, $need - $avail); 
  }
  
  /**
   * Return how much is available in this account for the given operation, without drawing on other accounts.
   * @param int $goods: purpose of the potential expenditure - see r\Acct::shortfall())
   * Do NOT take into account any advances from bank account (that would confuse the member's understanding of their credit line)
   */
  public function avail($goods = FOR_GOODS) {
    $a = $this;
    
    // no going into debt without permission or without a connected bank account
    if ($goods == FOR_USD or !$a->hasBank or $a->cttyA->noneg or !$a->debt or $a->depends) { // allow debt without autorefill (just don't allow setting debt ok without autorefill)
      $floor = max(0, $a->floor ?: 0) + ($a->giftPot ?: 0); // don't allow cashing out credit or gift cards
      if ($a->ourOwn) $floor = min($floor, -CG_LOAN_LIMIT); // allow CG to transfer money to bank account from a zero CG balance
    } else {$floor = $a->floor;}

    return round($a->balance - $floor, 2);
  }
  
  /**
   * Return the amount this account can draw from other accounts.
   * Repairs the B_DRAWS bit if all such relations have ended.
   */
  public function canDraw() {
    $a = $this;
    if (!$a->draws) return 0;
    extract(just('avail count', $a->drawSourcesSummary(), 0));
    if (!$count) $a->setBit(B_DRAWS, FALSE); // doesn't really have any drawable accounts
    return max($avail ?: 0, 0);
  }
  
  /**
   * Return a count of accounts we can draw from, and how much we can draw
   * @return ['avail'=>avail, 'count'=>count]
   */
  private function drawSourcesSummary() {
    $a = $this;
    return db\get("SUM(balance-IF(u.:IS_DEBT, floor, GREATEST(floor, 0))) AS avail, COUNT(*) as count",
                  "users u INNER JOIN u_relations r ON r.main=u.uid",
                  "r.other IN (:uids) AND r.:IS_DRAW AND r.main NOT IN(:uids)",
                  ray('uids', $a->uids));
  }
  
  /**
   * Return rows of accounts to draw from.
   * @return an array of records, each of which has uid and avail
   */
  private function drawSources() {
    $a = $this;
    $sql = <<< X
      SELECT u.uid, (balance-IF(u.:IS_DEBT, floor, GREATEST(floor, 0))) AS avail
      FROM users u INNER JOIN u_relations r ON r.main=u.uid
      WHERE r.other IN (:uids) AND r.:IS_DRAW AND r.main NOT IN (:uids)
X;
    return db\q($sql, ray('uids', $a->uids));
  }
  
  /**
   * Draw the wanted amount from other accounts, usually to make a purchase and maintain a non-negative balance.
   * @param numeric $need: the amount wanted
   * @param string $why: purpose of transfer
   * @return numeric: the amount drawn
   */
  public function draw($need, $why = '') {
    $a = $this;
    if (!$a->draws) return 0;
    list ($from, $to, $auto) = array(t(' from '), t(' to '), t('automatic transfer'));
    $left = $need; // how much left to be drawn
    $q = $a->drawSources();

    foreach ($q as $row) {
      extract(just('uid avail', $row, 0));
      $amount = round(min($left, $avail), 2);
      if ($amount > 0) {
        list ($fromQid, $toQid) = [r\qid($uid), $a->mainQid];
        $for = [$auto . $from . $fromQid, $auto . $to . $toQid];
        $z = be\transfer('draw', $this, r\acct($uid), $amount, $for, FOR_NONGOODS);
        if ($z->ok) $left -= $amount;
        if ($left <= 0) break;
      }
    }
    $msg = $left == $need ? 'cannot draw' : 'drew';
    $msg = tr($msg, 'amount', u\fmtAmt($need - $left));
    $a->tellIn(tr($msg, compact('why')));

    return round($need - $left, 2);
  }

  /**
   * Set or return the proxy for the person
   */
  public function proxy($priority = 1, $proxy = NULL) {
    $a = $this;
    $subs = ray('person priority', $a->id, $priority);
    if (empty($proxy)) { // return it
      return db\get('proxy', 'r_proxies', 'person=:person AND priority=:priority', $subs);
    } else { // set it
      db\del('r_proxies', 'person=:person AND priority=:priority', $subs);
      $subs['proxy'] = $proxy;
      db\insert('r_proxies', $subs);
    }
  }

  /**
   * Return the company's description.
   * @param bool $subtle: <make the categories a subtle last line>
   */
  public function coDesc($subtle = FALSE) {
    $a = $this;
    $uid = $a->id;
    $desc = u\parseUp($a->description);

    $sql = <<<EOF
      SELECT i.iid, i.industry FROM r_industries i 
      INNER JOIN r_user_industries ui ON ui.iid=i.iid 
      WHERE ui.uid=:uid ORDER BY i.industry
EOF;
    $cats = db\q($sql, compact('uid'))->fetchAllKeyed();
    $cats = empty($cats) ? '' : ($subtle
                                 ? ('<h3>Categories:</h3>' . join('<br>', $cats))
                                 : (t('Categories: ') . join(', ', $cats)) );
    
    return "$desc<br>$cats";    
  }
  
  /**
   * Mark two accounts joined (a joint account)
   * @param acct $b: the other account
   * Note we cannot split rewards and floor because they are recalculated in cron.
   */
  function join($b) {
    $a = $this;
    $fields = ray(MASTER_NUMERIC_FLDS);

    $DBTX = \db_transaction();
    foreach ([$a, $b] as $i => $ai) {
      $aj = $i == 0 ? $b : $a; // the other account
      $ai->update('jid', $aj->id);
      foreach ($fields as $k) $$k = nn($$k, 0) + ($ai->o($k) ?: 0);
    }
    
    $a->masterA->setBit(B_REFILL, $a->o_refill or $b->o_refill);
    $achMin = max($a->o_achMin, $b->o_achMin); // one of the $fields
    $minimum = $a->o_minimum + $b->o_minimum;
    $a->update(compact($fields)); // this sets master numeric fields to the sums, slave fields to zero
    unset($DBTX);
  }

  /**
   * Notify the user, according to their preferences
   * @param integer $uid: account record id
   * @param string $index: email index or message index
   * @param assoc $subs: substitutions/parameters for the message
   * @param string $topic: optional specific topic (otherwise look in $GLOBALS['topics']) -- ignored unless sending immediately
   * @param string $type: type of message, so we know when to send -- if empty, send immmediately
   */
  public function tell($index, $subs = [], $topic = '', $type = '') {
    $a = $this;
    global $channel, $testMessages;
    
    $subs['uid'] = $uid = $a->id;
    u\setDft($subs['qid'], $a->qid); // might have an agent too, so don't overwrite
    $subs['todayDesc'] = fmtDt(now());
    $subbedIndex = tr($index, $subs); // in case we use it for 
    $topic = $topic 
    ?: (nni($subs, 'topic') 
    ?: (nni($GLOBALS['topics'], $index) 
    ?: (strlen($subbedIndex) <= TOPIC_MAXEN ? $subbedIndex 
    : (substr(str_ireplace(t('he %PROJECT system'), t('he system'), $subbedIndex), 0, TOPIC_MAXEN) . '...')))); // index should never be used literally (wrong language) but more importantly never fail
    $subs['topic'] = tr($topic, $subs);
    $testMessages[] = compact(ray('uid index subs topic type'));

    if (nni($GLOBALS['emailSubjects'], $index)) return r\rMail($index, $a, $subs, nni($subs, 'reply') ?: 'ctty');

    // not sending an email right now; queue a notice or send immediately, as appropriate to type
    $message = $subbedIndex;
    $created = now();
    if ($type and $notices = ray($a->notices) and $notices[$type] == SEND_NOW) $type = ''; // immediate when no type or explicitly immediate
    if (test()) f('t.output', t('Actual %thing [%index] to %fullName: %message', 'thing index fullName message', $type ? t('notice') : t('message'), $index, $a->fullName, $message));

    if ($type) {
      return db\insert('r_notices', compact(ray('uid message created type')), 'msgid');
    } else {
      return r\rMail('message', $a, $subs + compact('message'), nni($subs, 'reply') ?: 'ctty');
    }
  }

  public function tellIn($index, $subs = [], $topic = '') {return $this->tell($index, $subs, $topic, SEND_IN);}
  public function tellOut($index, $subs = [], $topic = '') {return $this->tell($index, $subs, $topic, SEND_OUT);}
  public function tellMisc($index, $subs = [], $topic = '') {return $this->tell($index, $subs, $topic, SEND_MISC);}
  public function tellInOut($in, $index, $subs = [], $topic = '') {return $this->tell($index, $subs, $topic, $in ? SEND_IN : SEND_OUT);}

  private function freq($type) {return ray($this->notices)[$type];}

  public function redoBal() {
    $a = $this;
    $balance = db\sum('amount', 'tx_entries', 'uid IN (:uids)', ['uids'=>$a->uids]);
    if (empty($balance)) $balance = 0;
    if ($balance != $a->balance) r\tellAdmin(t('bad bal fixed'), ray('who was nowIs', "$a->fullName ($a->mainQid)", $a->balance, $balance));
    $result = db\update('users', ray('uid balance', $a->id, $balance), 'uid');
    u\EXPECT($result == 1, "trouble updating balance");
    $a->reread();
  }
  
  /**
   * Remove all joins and join requests, except with the specified account (if any).
   * @param acct $but: account record ID for which NOT to delete a join or join requests
   */
  function unjoinAllBut($but = FALSE) {
    $a = $this;

    $where = 'permission=:joint AND :id IN (main, other)';
    $subs = ray('joint id', r\perm(B_JOINT), $a->id);

    $DBTX = \db_transaction();
    if ($jid = $a->jid AND $jid != $but) { // unravel a consummated join
      $b = r\acct($jid); // ignore param (actual joined account will be unjoined and any join requests zapped)
      foreach ([$a, $b] as $ai) {
        $ai->update1('jid minimum', 0, max($a->o_minimum, $b->o_minimum));
      }

      $a->redoBal();
      $b->redoBal();

      if ($a->ok and $b->ok) { // no need to settle with closed or not-yet-open account
        $diff = $a->balance - $b->balance;
        if ($xfr = round($diff / 2, 2)) {
          $z = be\transfer('payment', $a, $b, $xfr, t('joint account settlement'), FOR_USD, ['force'=>1]); // this sometimes generates a warning to staff
          u\EXPECT($z->ok, t('Join account settlement failed for %p1 and %p2', 'p1 p2', $a->fullName, $b->fullName));
        }
      }
    } elseif ($but) {
      $where .= ' AND :but NOT IN (main, other)';
      $subs += compact('but');
    }
    
    db\del('u_relations', $where, $subs); // zap one or more joins (or requested joins) for this account
    unset($DBTX);
  }

  /**
   * De-activate the account for reasons of security or data integrity.
   * @param string $why: the reason for suspending (to tell member and staff)
   */
  public function suspend($why = '') {
    $this->setBit(B_OK, FALSE); // suspend the account
    if ($why) {
      $this->tell('account suspended', compact('why'));
      $notes = r\stampNote(t('account suspended') . " $why") . nn($this->notes);
      $this->update(compact('notes'));
      r\tellAdmin('account suspended', ray('uid fullName why', $this->id, $this->fullName, $why));
    }      
  }
  
  /**
   * Return an auxiliary filename for the account.
   * @param bool $ideal: return the ideal normal name, even if the file does not exist (default FALSE)
   * @return: the relative file path (relative to Drupal)
   */
  public function photoFilename($ideal = FALSE) {
    return ($ideal or $this->hasPhoto)
      ? r\pic("$this->id-$this->cardCode.jpg")
      : ($this->co ? R_DFT_PICTURE_WIDE : R_DFT_PICTURE);
  }
  
  public function cardCode() {return $this->noAgent() ? $this->cardCode : $this->agentA->cardCode2;} // check for agentCode to handle admin acting on behalf of person (as though proSe)
  
  private function noAgent() {return $this->proSe ?: ($this->admin and !r\relation(1, $this->id, $this->agentId));}

  /**
   * Create an rCard security code for the given account (either for an individual or a company agent).
   */
  function makeCardCode($newCode = NULL) {
    $a = $this;
    $aA = $a->agentA;
    $noAgt = $a->noAgent();
    u\EXPECT(!($a->co and $noAgt) or (test() and $newCode == ''), 'companies cannot have a cardCode'); // allow tests to set company cardCode blank
    $field = $noAgt ? 'cardCode' : 'cardCode2';
    $qid = $noAgt ? $a->mainQid : $a->qid;
//    if ($aA->$field) r\badCard($qid, $aA->$field); // (don't mark previous code bad if none)
//    if ($oldCode = $aA->$field) db\insert('r_bad', ray('qid code created', $qid, $oldCode, now()), 'created');
    $aA->update($field, $newCode ?: r\cardCode()); // resave the secure fields
  }
    
  /**
   * Mark a membership step as completed.
   * @param string $step: a named step (see S_ALL, etc)
   * @param bool $done: whether to set the step done or not done
   * @param assoc $details: any details to report to the staff
   * @return the next step (FALSE if none)
   */
  function stepDone($step, $done = TRUE, $details = []) {
    $a = $this;
    
    $i = nni(r\allSteps(), $step, FALSE);
    u\EXPECT($i !== FALSE, 'bad step: ' . $step);
    $a->stepDoneForNow($step, $done);
    $a->setBit($i, $done, 'steps'); // done forever
    
    $nextStep = $a->nextStep();
    if ($done and empty($nextStep)) {
      $a->update('task', '');
      if (!$a->member) {
//        r\tellCAdmin(t('New Member (%name)', ['name' => $a->fullName] + $details));
        $a->setBit(B_MEMBER);
        $a->update('tickle', now());
      }
    } elseif ($nextStep == 'partnerend' and count($a->stepsLeft) > 1) { // parnerend step should always be last
      $stepsLeft = $a->stepsLeft;
      unset($stepsLeft['partnerend']);
      $stepsLeft[] = 'partnerend';
      $a->update(compact('stepsLeft'));
    }
    return $nextStep;
  }

  /**
   * Remove the specified step from the current task (but don't mark it complete).
   */
  public function stepDoneForNow($step, $done = TRUE) {
    $a = $this;
    $stepsLeft = $a->stepsLeft();
    $p = array_search($step, $stepsLeft);
    $hasStep = ($p !== FALSE);
    if ($done and $hasStep) unset($stepsLeft[$p]);
    if (!$done and !$hasStep) $stepsLeft[] = $step;
    $a->update('stepsLeft', array_values($stepsLeft)); // renumber and update
  }

  /**
   * Return an array of the remaining steps in the given (or current) task.
   * @param string $task: the task of interest, such as card or voice (defaults to current task)
   * @see also $this->stepsLeft, which is the steps remaining in the current task, in order (possibly reordered)
   */
  public function stepsLeft($task = NULL) {
    $a = $this;
    
    if (!$steps = isset($task) ? ray(r\taskSteps($task)) : $a->stepsLeft) return [];
    $res = []; foreach ($steps as $k) if (!$a->stepIsDone($k)) $res[] = $k;
    if (!isset($task)) $a->update('stepsLeft', $res);
    return $res;
  }
    
  /**
   * Go to the next step
   * @param string $stepDone: the step just completed, if any
   * @param string $msg: basic message to display if completing or re-completing a step (defaults to "info saved")
   * @param string $msg: (RETURNED) a status message to display, if any 
   * @return the url of the next account-setup step ('', if no step)
   */
  public function nextStepUrl($stepDone = '', &$msg = NULL, $info = []) {
    $a = $this;
    u\setDft($msg, $stepDone ? 'info saved' : '');
    if ($a->closed) return '';
    $task0 = $a->task; // remember current task before marking step done

    if ($stepDone) {
      $stepCounts = !$a->stepIsDone($stepDone);
      $a->stepDone($stepDone, TRUE, $info);
    } else { $stepCounts = FALSE; }
    
    if ($a->task and $nextStep = $a->nextStep()) {
      if ($stepDone and in($stepDone, r\taskSteps($a->task))) $msg = u\joi('|', [$msg, 'step completed']); // say completed only when relevant
      return ray(S_ALL)[$nextStep] ?: "settings/$nextStep";
    }

    if ($stepDone and $a->member and $task0 != '') { // no current task (nothing to be done next) and just did the final step
      if (!$a->ok and ($a->co ? ($a->helperA->ok or $a->agentA->ok) // automatic approval if company agent is OK,
        : ($a->hasFid and !$a->risk('ssnOff')))) { // OR if individual is verified (helperA needed for verifyemail.inc)
        include_once R_ROOT . '/cg-activate.inc';
        r\activate($a, $a->helper ?: 0);
      }
      $msg = u\joi('|', [$msg, 'success']);
      if ($a->ok) { // account needs no approval (accounts needing approval get a persistent message on the dashboard)
        $msg2 = $a->co ? 'co ok|pioneer thanks'
        : ($task0 == 'person' ? 'member ok|join thanks'
        : ($task0 == 'card' ? 'card ok'
        : ($task0 == 'vote' ? 'voter ok|pioneer thanks' : '') ));
        u\EXPECT($msg2, 'bad task');

        $msg = u\joi('|', [$msg, $msg2]); // show on display, not on done
        $a->update('stepsLeft task', '', ''); // mark task complete
      }
    }

    return '';
  }

  public function setTask($task) {$this->update('task stepsLeft', $task, $this->stepsLeft($task));}
  public function stepIsDone($step) {return (bool) u\getBit($this->steps, nni(r\allSteps(), $step));}
  public function stepsDone($task) {
    foreach (ray(r\taskSteps($task)) as $step) if (!$this->stepIsDone($step)) return FALSE; 
    return TRUE;
  }
  public function nextStep() {return ($steps = $this->stepsLeft) ? $steps[0] : FALSE;}
  public function stepCount($task = NULL) {return count($this->stepsLeft($task));}

  /**
   * Check SSN during a signup step (normally on the verifyId step as soon as we get federalId, unless already verified)
   */
  public function verifySsnInBackground() {
    $a = $this;
    global $base_url;
    if (!$a->hasFid) return;
    if ($a->ssnData and !$a->ssnErr) return;
//      w\jsx('get-ssn');
    u\post("$base_url/ajax", ray('op sid data', 'ssn', session_id(), ''));
  }

  /**
   * Create a once-use password and return it.
   * @return the once-use password
   */
  function oneTimePass() {
    global $base_url;
    $a = $this;
    $pass = u\randomString(R_CODE_LEN, 'word'); // use
    $expires = now() + HOUR_SECS * R_SIGNIN_HOURS;
    $a->update('oneTimePass', compact('pass', 'expires'));
    return $pass;
  } 

  /**
   * Say whether the password is acceptable.
   * @param string $password: the password supplied by the user
   * @param string $passFieldName: password field name (none if using only oneTimePass)
   * @param string $err: (RETURNED) the error message, if any
   * @return <password is good>
   */
  function passwordOkay($password, $passFieldName = '', &$err = '') {
    $a = $this;
    if ($a->oneTimePass) {
      extract(just('pass expires', $a->oneTimePass));
      if ($password == nn($pass)) return ($a->admin or now() < nn($expires)) ?: !($err = 'pass expired');
    }

    if (!strlen($a->$passFieldName??'')) return !$err = 'password required';
    require_once DRUPAL_ROOT . '/includes/password.inc';
    $hash = \_password_crypt('sha512', $password, $a->$passFieldName);
    return ($hash and $a->$passFieldName == $hash) ?: (!$err = t('bad login', '_a', w\atag('/settings/password')));
  }
  
  /**
   * Return the Community Admin's account record ID.
   */
  function cAdminUid() {
    return db\get('uid', 'users', 'community=:ctty AND :IS_ADMIN', ray('ctty', $this->community));
  }
  
  /**
   * Return the community admin's contact info.
   */
  function cAdminContact() {
    if (!$id = $this->cAdminUid()) return t('(no Community Admin)');
    $a = r\acct($id);
    return "$a->fullName - $a->email";
  }
  
  /**
   * Return an assoc of individual (or joint) account statistics.
   * @return [returnMo, return, cttyBeneMo, cttyBene]
   * OUT OF DATE and NOT CURRENTLY USED
   */
  public function j_stats() {
    $a = $this;
    $fields = 'returnMo return cttyBeneMo cttyBene';
    if (!$a->member or $a->isCtty) return ray($fields, 0, 0, 0, 0);
    
    $stats = ($stats = $a->stats) ? unserialize($stats) : [];

    if ($jid = $a->jid) {
      $j = r\acct($jid);
      $jstats = ($jstats = $j->stats) ? unserialize($jstats) : [];
      foreach ($stats as $k => $v) {
        $jv = nni($jstats, $k, 0);
        $stats[$k] = u\abbreviates('avg', $k) ? ($v + $jv) / 2 : ($v + $jv);
      }
      $created = round(($a->created + $j->created) / 2);
    } else $created = $a->created;
    
    extract($stats);
    $years = round((today() - strtotime('today', $created)) / DAY_SECS) * DAY_SECS / YEAR_SECS;
    // rounding is to assure consistency for tests, despite daylight savings time changes
    $returnMo = nn($avgBalPastMo, 0) > 0 ? 
      number_format(100 * 12 * nn($extraPastMo, 0) / $avgBalPastMo, 1)
      : (nn($benePastMo, 0) + nn($extraPastMo, 0) > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $return = ($years > 0 and nn($avgBalEver, 0) > 0) ? 
      number_format(100 * nn($extraEver) / $avgBalEver / $years, 1)
      : (nn($extraEver, 0) > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $cttyBeneMo = u\fmtAmt(nn($giftsPastMo, 0) + max(0, nn($bankedPastMo, 0)) + nn($benePastMo, 0) * (1 + CC_RATE / 100));
///       debug(compact(ray('giftsEver bankedEver beneEver')));
    $cttyBene = u\fmtAmt(nn($giftsEver, 0) + max(0, nn($bankedEver, 0)) + nn($beneEver, 0) * (1 + CC_RATE / 100) + r\cttyPaidEver($a->community) / (nn($pAccts) ?: 1));

    return compact(ray($fields));
  }
   
  /**
   * Return an SMS number for the account.
   * @return: the number or null if none
   */
  public function smsNumber() {  
    $id = $this->id;
    return db\get('code', 'r_boxes', "uid=:id AND code REGEX '+[:digit:]{7,15}'", compact('id')); // was status=:SMS_PRIMARY
  }

  /**
   * Return the total waiting to be credited as a transfer FROM (or if negative result, TO) the member's bank.
   * @param numeric $combinable: (RETURNED) how much is waiting and checks haven't been printed yet (incoming only)
   * @param int $combineTxid: (RETURNED) record id of USD transfer request in txs2_bank that can be combined (if none, zero)
   */
  public function waitingFromBank(&$combinable = 0, &$combineTxid = 0) {
    $a = $this;
    $sql = <<< o
      SELECT SUM(amount) AS amt, SUM(IF(deposit, 0, amount)) AS combinable,
        MIN(IF(deposit OR amount=0, NULL, txid)) AS combineTxid
      FROM txs2_bank WHERE payee IN (:uids) AND NOT completed
o;
    extract(db\q($sql, ray('uids', $a->uids))->fetchAssoc());
    if ($combinable <= 0) $combinable = $combineTxid = 0;
    return $amt;
  }
  
  /**
   * Return the amount of pending bank transfers the member has already been credited with, against their credit line.
   */
  public function advances() {
    return db\sum('amount', 'txs2_bank', 'payee IN (:uids) AND amount>0 AND completed AND :NOW-created<:DAY_SECS*:USDTX_DAYS', ['uids' => $this->uids]);
  }

  /**
   * Transfer funds to an account from a connected bank account or drawable Common Good account.
   * Call with:
   *   $completed = $a->getFunds(); // brings balance up to zero or (if autorefill is yes) the target balance
   *   $completed = $a->getFunds($amount, $why); // get a specific amount for a specific purpose
   * Called for investments, gifts, invoice payment, and autorefills.
   * @param numeric $amount: the amount needed
   * @param string $why: purpose of transfer
   * @return completed: <bank transfer (in or out) is "completed" has been credited to the account>
   */
  public function getFunds($amount = NULL, $why = NULL) {
    $a = $this;

    if ($a->nonudge and !$a->ok) u\FAIL('trying to get funds from a nonudge non-member');
    if ($a->hasBank) {
      $waiting = 0; // we are not charged per transfer so this is simpler (was $a->waitingFromBank($combinable, $txid);)
      if (round($amount - $waiting, 2) <= 0) return 0;
      list ($xid, $amtDone, $completed, $report) = $a->bank($amount, $why);
      $amount -= $waiting + $amtDone;
      $msg = $amount > 0 ? 'automatic when funded' : $report;
      $subs = [];
    } else {
      list ($amtDone, $msg) = [0, 'cannot bank|when funded|how to fund'];
      $subs = ray('tofrom why', 'from', tr('to target'));
      $completed = FALSE;
    }

    w\say($msg, $subs);
    if ($amount > 0) $a->tellOut($msg, $subs); // already told, if the whole amount got transferred

    return $completed;
  }
  
  /**
   * Transfer funds to or from a connected bank account.
   * @param numeric $amount: the amount to transfer FROM or (if negative) TO the bank
   * @param string $why: purpose of transfer
   * @param assoc $info: other parameters, including:
   *   explicit: <user requested this transfer explicitly>
   *   recursId: the tx_timed ID if this transfer is recurring
   *   cat: the expense category, if this account is sponsored
   *
   * @return [xid, amtDone, report] where:
   *   xid: the transfer transaction ID
   *   amtDone: the amount transferred
   *   completed: (bool) <bank transfer is "completed" and CG account credited>
   *   report: actual message to say to account-owner about the transfer (but not by email because we do that herein)
   */
  public function bank($amount, $why, $info = []) {
    $a = $this;
    u\EXPECT($a->hasBank, 'banking with no bank');
    extract(just('explicit recursId cat', $info, [FALSE, NULL, NULL]));

    $report = '';
    if (!$amount = round($amount, 2)) return [NULL, 0, NULL, NULL]; // no zero requests at this time (to pre-verify bank account)

    $payee = $a->id;
//    $okNow = ($amount < 0 or $a->bankOk); // 
    $okNow = TRUE; // "okay to create the request NOW" - trust everyone unless and until this becomes a problem
    if (!$okNow) $a->verifyBank();
    $msg = 'banked';
    $combined = FALSE;
    $previous = $total = NULL;
    $waiting = $a->waitingFromBank($combinable, $txid);
    $combinable = 0; // we don't get charged per transfer, so don't combine
  
    if ($amount > 0) { // bringing money in
      if (FALSE and !$explicit) { // don't combine
        $amount -= $waiting;
        if ($amount <= 0) return [NULL, 0, NULL, NULL]; // do nothing if we already have plenty waiting
      }
      $amount += $combinable;
      if ($a->refill and !$explicit) $amount = max($amount, $a->achMin); // apply minimum transfer amount, if member has agreed to that deal

      if ($combinable and $combined = db\update('txs2_bank', compact(ray('txid amount')), 'txid')) {
        $msg .= '|combined';
        list ($previous, $total) = [u\fmtAmt($combinable), u\fmtAmt($amount)];
        $xid = db\get('xid', 'txs2_bank', compact('txid'));
      }
    }

    $amount = round($amount, 2);
    $fuMsg = '';

    if (!$combined) {
      u\setDft($created, $okNow ? now() : strtotime('+7 days')); // delay long enough to identify and address problems
      u\setDft($completed, ($amount < 0 or ($okNow and $amount + $waiting <= -$a->floor)) ? $created : 0);
      $xid = be\createUsdTransfer($a, $amount, compact(ray('completed created recursId cat')))->xid;
      if ($fuMsg = be\usdTxFollowup($xid, FALSE)) $fuMsg = '|' . $fuMsg; // fuMsg is not needed here (use 'available now' instead)
      u\EXPECT($xid, 'saving usd record');
    }

    if ($amount < 0) r\tellAdmin(t('outgoing bank transfer'), ray('who amount', $a->fullName, -$amount));
    
    if ($combined) $amount -= $combinable; // don't include previous amount in notice to member
    if ($amount > 0) $msg .= '|bank tx number' . (nn($completed) ? '|available now' : '');
    list ($action, $tofrom) = $amount < 0 ? [t('deposit'), t('to')] : [t('draw'), t('from')];
    $subs = ray('action tofrom amount checkNum previous total why', $action, $tofrom, u\fmtAmt(abs(nn($amount))), $xid, $previous, $total, nn($why));
    $a->tellInOut($amount > 0, $msg, $subs);
    $report = tr($msg, $subs); // for return

    return [nn($xid), $amount, $completed, $report];
  }
  
  /**
   * Create a zero USD transfer record to verify the bank account.
   */
  public function verifyBank($channel = TX_SYS) {
    $a = $this;
    $info = ray('amount payee bankAccount', 0, $a->id, nni($a->vsecure, 'bankAccount') ?: NULL);
    if (test() and empty($bankAccount)) unset($info['bankAccount']); // otherwise t\verifyRecord fails
    if (db\exists('txs2', $info)) return; // already being verified
    $txid0 = db\max('txid', 'txs2', 'txid<999999');
    for ($txid = $txid0; $txid < 999999; $txid++) { // actual transfers start sometime after 999,999
      if (db\exists('txs2', 'txid=:txid', compact('txid'))) continue;
      if ($txid = db\insert('txs2', $info + compact(ray('txid channel')), 'txid')) break;
    }
    u\EXPECT($txid, 'ran out of low txids');
  }      

  /**
   * Automatically cashout accounts that choose to, leaving average weekly gross (over past 6 months) in the account. Weekly gross is figured as -6/26th of the floor (because there are 26 weeks in 6 months and floor is based on 1/6 of 6 months' gross).
   * @param string $when: weekly or monthly
   */
  public function cashout($when) {
    $a = $this;
    
    if (!$a->hasBank) return;
    if ($a->waitingFromBank($combinable) > 0) return; // no cashout if waiting to bring some in
    $cashout = round($a->balance - -$a->floor * 6 / 26 - 4.99, -1); // round average weekly activity down to nearest $10
    if ($cashout < R_ACHMIN) return;
    $a->bank(-$cashout, t('(your %when automatic bank transfer)', compact('when')));
  }
  
  /**
   * Suggest autorrefills or a higher minimum, etc. (because of a failed purchase).
   * This might make sense to use on the WEB interface also (just change the $channel line below), but the message would need to be added AFTER the basic error message.
   */
  public function suggestAuto() {
    $a = $this;
    global $channel; if (!in_array($channel, [TX_APP])) return;
    
    $web = ($channel == TX_WEB);

    if (!$web) $msg[] = 'you were short';
    $msg[] = $a->hasBank ? ($a->refill ? 'suggest higher target' : 'suggest refills') : 'how to fund';

    $args = [];
    if ($a->secret) {
      $args['_aSecret'] = $web ? w\atag('/settings/preferences') : $a->doLink('nosecret');
      $msg[] = 'be not secretive';
    }
    if (!$a->debt and $a->floor < 0) {
      $args['_aDebt'] = $web ? w\atag('/settings/preferences') : $a->doLink('debtok');
      $msg[] = 'try debt';
    }
    
    $msg = join('|', $msg);
    if ($web) return t($msg, $args); else $a->tellMisc($msg, $args);
  }
  
  /**
   * Return the next suggested date, type, and description to contact this member for a standard checkin.
   * @param mixed $done: <asking because a checkin was just completed> or "activate"
   * @return [$type, $date] or ['', 0, ''] if none
   *   $type: a one-word call type
   *   $date: the suggested date
   */
  public function nextTickle($done = FALSE) {
    $a = $this;

    $now = now();
    $activate = ($done . '' == 'activate');
    if ($activate) {
      list ($done, $activated) = ['', $now];
    } else {
      if (!$a->member) {
        if ($a->nonudge or $now - $a->created < HOUR_SECS) return ['', 0];
        return [$a->task == ($a->co ? 'co' : 'person') ? 'setup' : 'pre', max(0, $a->created)]; // pre's (archaic) should be deleted
      } elseif (!$a->ok) return ['activate', $now];
      $activated = max($a->activated, strtotime('1/1/2013')); // max is for testing
    }
    
    if ($a->signupCo) $signupCo = w\signupCoDisplay($a->signupCo) . ',';
    $daysIn = ($now - $activated) / DAY_SECS; // how many days after activation are we
    $tickleDaysIn = $a->tickle ? ($a->tickle - $activated) / DAY_SECS : 0; // how many days after activation to tickle

    if ($activate or ($tickleDaysIn < 90 and $daysIn < ($done ? 8 : 90))) { // not welcoming if wrong time or done at right time
      $when = $activated + (($a->giftsDesc() and !$a->cttyA->isRegion) ? TICKLE_WELCOME : TICKLE_DELAYED) * DAY_SECS;
      return ['welcome', $when];
    }
    $yearsIn = max(1, round($daysIn / 365.25));
    if ($done and abs($yearsIn * 365.25 - $daysIn < 30)) $yearsIn++;
    return ['annual', strtotime("+$yearsIn years", $activated)]; // Annual
    // if (($daysIn + 30) mod 365 < 2 * 30) 
    //return [0, ''];
  }

  /**
   * Return a description of the members gift history. The total gifts include first planned gift, if none completed yet.
   * A gift is a transaction where one entry refers to the member and another entry refers to CG.
   * @param string $period: (RETURNED) frequency of latest gift
   * @param string $totalGifts: (RETURNED) total gifts with no mention of latest
   * @return: description of gifts (FALSE if none)
   */
  public function giftsDesc(&$period = '', &$totalGifts = '') {
    $a = $this;
    $gift = $honored = $last = '';
    $subs = ['id' => $a->id];

    $sql = <<< X
      SELECT tm.start AS recurStart, tm.amount AS recurAmt, tm.period, tm.periods, h.honor, h.honored
      FROM tx_timed tm
      LEFT JOIN r_honors h ON h.uid=tm.from
      WHERE tm.action=:ACT_PAY AND tm.from=:id AND tm.to=:CGID
      AND tm.end IS NULL
X;
    if ($res = db\q($sql, $subs)->fetchAssoc()) {
      extract($res);
      $honored = $honored ? (u\honorDesc($honor) . $honored) : '';
      if ($period) {
        $recurDesc = ucwords(r\recurDesc($period, $periods));
        $recurAmt = u\fmtAmt($recurAmt);
        $gift = "$recurAmt $recurDesc";
      }
    }

    $sql = <<< X
      SELECT created AS lastGiftDate, amt AS lastGift 
      FROM txs_noreverse
      WHERE uid1=:id AND uid2=:CGID AND :IS_GIFT
      ORDER BY created DESC LIMIT 1
X;
    if ($res = db\q($sql, $subs)->fetchAssoc()) {
      extract($res);
      $last = t('Last: %lastGift (%lastGiftDate)', 'lastGift lastGiftDate', u\fmtAmt($lastGift), fmtDt($lastGiftDate));
    }
    
    $roundups = $a->roundup ? t('Roundups') : '';
    $crumbs = $a->crumbs > 0 ? t('%crumbs% Crumbs', 'crumbs', $a->crumbs * 100) : '';
    $all = u\joi(t(' plus '), [$gift, u\joi(t(' and '), [$roundups, $crumbs])]) ?: t('none');
    $all .= $honored;
    if ($ever = $a->totalGifts()) $all .= t('<br>%ever to date. ', 'ever', u\fmtAmt($ever)) . $last;

    return $all;
  }

  /**
   * Return a "no signin required" action. Called directly from a\export and ->doCode (above).
   * The account should be the recipient of the emailed link, if more than one account is involved.
   * @param string $op: what to do (NULL means allow any no-sign-in operation)
   * @param numeric $v: an amount, identifier
   * @param int $expire: number of days until link expires
   * @param assoc $info: other parameters (sql, subs, etc.)
   * @see also r\Web\rdo()
   */
  function doCode($op = NULL, $v = NULL, $expire = 90, $info = []) {
    if (isset($expire)) $expire = now() + $expire * DAY_SECS;
    $qid = $this->mainQid;
    foreach (ray('op qid v expire') as $k) if (isset($$k)) $info[$k] = $$k;
    return u\cryRay($info);
  }
  
  /**
   * Return a link to a "no signin required" code.
   * @return <a> tag guts for a clickable link that will do something without requiring the member to sign in
   */
  function doLink($op = NULL, $v = NULL, $expire = 90, $info = []) {
    return w\atag(BASE_URL . "/do/" . $this->doCode($op, $v, $expire, $info));
  }
  
  /**
   * Set the bit (identified by number or name) in the "risks" integer bit collection field.
   * @param mixed $bit: number of bit to set (0 - 31) or name of bit
   * @param bool $on: whether to set it ON or OFF
   */
  public function setRisk($bit, $on = TRUE) {$this->setBit($this::riskBit($bit), $on, 'risks');}
    
  public function risk($bit) {return u\getBit($this->risks ?: 0, $this::riskBit($bit));}
  
  /**
   * Return the bit number for risk bit name.
   * @param mixed $bit: the bit name or number
   * @return the bit number
   */
  private static function riskBit($bit) {
    if (is_numeric($bitName = $bit)) return $bit;
    $acctRiskBits = array_flip(array_keys(ray(K_ACCT_RISKS)));
    $txRiskBits = array_flip(array_keys(ray(K_TX_RISKS)));
    return is_numeric($bit = nni($acctRiskBits, $bitName)) ? $bit : $txRiskBits[$bitName];
  }

  /**
   * Set each admin bit listed in the given array of A_LIST bit numbers or names.
   */
  public function setAdminBits($vs) {
    $cans = 0; foreach ($vs ?: [] as $bit) $cans |= u\bit($bit, 'a');
    if ($cans) {
      db\updateOrInsert('admins', ray('uid can', $this->id, $cans), 'uid');
    } else db\del('admins', 'uid', $this->id);
  }

  /**
   * Say whether the current agent has the specified admin permission(s).
   * Permissions that require "very secure" data, are denied unless the admin has scanned a SuperAdmin card.
   * @param string $bitName: a space-delimited string array of bit names to check (see A_LIST)
   * @return <the agent for this account has all the listed permissions>
   */
  public function adminCan($bitName = NULL) {
    global $mya;
    $a = $this; $uid = $a->agentId;

    if (!$a->admin) return FALSE; // only admins have admin powers
    if (strhas($bitName, ' ')) {
      foreach (ray($bitName) as $k) if (!$a->adminCan($k)) return FALSE;
      return TRUE;
    }
    
    $bitName = lcfirst($bitName); // in case this was a pseudo-property of the account object, now stripped of its "adm" prefix
    $cans = $a->agentA->adminCans;
    if ($uid == UID_SUPER) return TRUE; // uid 1 always has all powers (as a backup for one trusted admin -- not to be used otherwise)
    if (!($cans & r\adminCanBit($bitName))) return FALSE; // this admin doesn't have that bit
    if (in($bitName, A_VLIST)) return ($a->admin and r\cook('vKeyPw')); // need admin and V permission for these
    return TRUE;
  }
   
  //  private static function flagBit($bit) {return is_numeric($bit) ? $bit : u\consta('b', $bit);}
  public function coCan($bit = NULL) {return u\getBit((is_numeric($bit) and $bit > B_MAX) ? $this->coFlags2 : $this->coFlags, $bit, 'co');}
  public function setCoBit($bit, $on = TRUE) {$this->setBit($bit, $on, 'coFlags');}
  
  public function setCoCans($cans) {
    $coFlags = $this->coFlags;
    for ($i = 0; $i < 2 * APP_CAN_BITS; $i++) {
      $bit = u\bit(APP_CANS + $i);
      $coFlags = isset($cans[$i]) ? ($coFlags | $bit) : ($coFlags & ~$bit);
    }
    $this->update(compact('coFlags'));
  }

  /**
   * Set all account risk bits at once (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setRisks($values) {
    if (!is_array($values)) return; // this happens in testing
    $risks = $this->risks;
    $riskBits = array_values(just(K_ACCT_RISKS_EDITABLE, array_flip(array_keys(ray(K_ACCT_RISKS))))); // editable risk bits
    foreach ($riskBits as $bit) u\setBit($risks, $bit, isset($values[$bit]));
    $this->update(compact('risks')); // update all at once, for efficiency
  }
  
  /**
   * Set all appropriate bits in the flags field (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setBits($values) {
    $a = $this;
    u\setDft($values, []); // fails in arg list (dunno why)
    $flags = $a->flags;
    foreach ($a->adminables() as $bitName) { // set all these on or off
      //      if (substr($bitName, 0, 1) == 'u') continue; // lowercase u means undefined
      $bit = u\consta('b', $bitName);
      $on = isset($values[$bit]); // isset because bit 0 is 0 when checked
      u\setBit($flags, $bit, $on);
    }
    $a->update(compact('flags'));
  } 

  /**
   * Set all appropriate bits in the company flags field (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setCoFlags($values) {
    $a = $this;
    u\setDft($values, []); // fails in arg list (dunno why)
    $coFlags = $a->coFlags;
    $i = 0; // display position
    foreach (ray(CO_FLAGS) as $bit => $bitName) { // set all these on or off
      if (!$bitName) continue;
      $on = isset($values[$i]); // isset because bit 0 is 0 when checked
      u\setBit($coFlags, $bit, $on);
      $i++;
    }
    $a->update(compact('coFlags'));
  } 

  /**
   * Say whether another active account has the same address
   */
  public function dupAddr() {
    $a = $this;
    if (!$address = $a->address) return FALSE;
    $q = db\q('SELECT uid FROM users WHERE :IS_OK AND uid<>:id AND zip=:zip', ray('id zip', $a->id, $a->zip));
    while ($row = $q->fetchAssoc()) if (r\acct($row['uid'])->address == $address) return TRUE;
    return FALSE;      
  }

  /**
   * Change the account's community.
   * @param int $newCtty: the new community uid
   * @param bool $retro: (UNUSED) <change rewards transactions retroactively>
   * @param string $err: (RETURNED) the error message, if any
   * @return <success>
   */   
  public function changeCtty($newCtty, $retro = FALSE, &$err = '') {
    $a = $this;
    if (!db\exists('users', 'uid<1 AND uid=:newCtty', compact('newCtty'))) return !$err = 'bad ctty';
    
    $a->update('community', $newCtty);
    return TRUE;
  }

  /**
   * Set the account's latitude and longitude.
   * For example: eachA(function ($a) {$a->setLocus();}, 'latitude=0 AND longitude=0');
   *
   * Choices for geocoding services:
   * https://api.opencagedata.com/geocode/v1/json?q=ADDRESS&key=API_KEY (free for up to 2,500 a day)
   * https://maps.googleapis.com/maps/api/geocode/json?address=ADDRESS&key=API_KEY (we are not signed up yet, 0.5c each)
   * https://geocoding.geo.census.gov/geocoder/locations/onelineaddress?format=json&benchmark=Public_AR_Current&address=ADDRESS (no API_KEY needed, but fails 7% of the time and no way to approximate the address)
   */
  public function setLocus($lat = NULL, $lon = NULL) {
    $a = $this;
    if (!is_null($lat)) return $a->update('latitude longitude', $lat, $lon);
    
    list ($lat, $lon, $zip) = u\getLocus($a->address, $a->city, $a->state, $a->zip);
    if ($ok = ($lat or $lon)) $a->setLocus($lat, $lon);
    $a->setRisk('addrOff', !$ok);
  }    
   
  /**
   * Say whether this settings/agent has the permission.
   * @param int $bit: the permission in question (DEFAULT B_READ)
   */
  public function can($bit = B_READ) {
    $a = $this;
    
    if ($a->isCanonic and in($bit, B_MEMBER, B_CONFIRMED, B_OK, B_NONUDGE, B_DEBT)) return TRUE;

    if ($bit <= substr_count(B_LIST, ' ')) { // ordinary bits
      if ($bit == B_DEBT and $a->underage) return FALSE; // credit card regulations say no credit line if underage
      if ($bit == B_ADMIN) {
        if ($a->agentId == UID_SUPER) return TRUE;
        if (!$a->proSe) return ($aa = $a->agentA and $aa->can($bit)); // admin permissions are for agent instead (in tests, agent sometimes doesn't exist)
      }
      return (bool) ($a->flags & (1 << $bit)); // these are easy. be efficient.
    }

    if ($bit > B_RELATED and $bit <= B_JOINT) return $a->relCan($bit);
    u\FAIL('bad can bit: ' . $bit);
  }

  /**
   * Say whether the agent has a particular permission on the account they are managing.
   */
  private function relCan($bit) {
    $a = $this;
    $aa = $this->agentA;

    if ($bit == B_BUY and $a->trialco) return FALSE; // trial companies can't buy
    if (in($bit, [B_SELL, B_BUY]) and !$a->ok) return FALSE; // inactive accounts can't transact
    if ($a->proSe) return TRUE;

    $perm = $a->permission; // get the permission level from the relations record
    $adminPerm = $aa->id == UID_SUPER ? B_MANAGE
    : (!$aa->admin ? 0
    : ((!($a->admRegion and R_ADMIN_CAN_MANAGE_CTTYS) and $a->community != $aa->community) ? 0
    : ($aa->admManageAccts ? B_MANAGE
    : ($aa->admPayFrom ? B_BUY
    : ($aa->admChargeFrom ? B_SELL
    : ($aa->admSeeAccts ? B_READ : 0) )))));

    if (!$perm and !$adminPerm) return FALSE;
    return (max($perm + B_RELATED, $adminPerm) >= $bit);
  }

  /**
   * Encrypt the region's private key (for decrypting highly sensitive data) for a new regional admin.
   * @param string $vKey: key text (PEM-formatted or not) or file path with key text
   * @param string $vKeyPw: password to use in u\b64 format (defaults to 32 random pseudo-bytes)
   * @param bool $showQr: <return a QR as opposed to just b64 of the vKeyPw> (default TRUE)
   *   If $vKey is omitted, get it from the current signed-in superAdmin account
   *   WARNING: This function invalidates the account's current vKeyE and vKeyPw, if any
   *   vKeyE (vKey Encrypted) is vKey R-encrypted (or r-encrypted) with password vKeyPw
   *   vKeyE gets saved in the admins table. vKeyPw is returned, b64'd, for cgAdmin.html on a flash drive or as html for a printable QR.
   * @param bool $anonymizing: if true, use encryption type "r" for storing vKeyE (instead of "R")
   * @return HTML for a printable QR image for the account holder to scan to get super powers
   */
  public function makeVKeyE($vKey = NULL, $vKeyPw = NULL, $showQr = TRUE, $anonymizing = FALSE) {
    $a = $this; $uid = $a->id;
    $vKey = isset($vKey) ? u\unfmtKey($vKey) : r\vKey();
    if (!$vKey) return t('No private key given or available.');
    require_once R_ROOT . '/forms/showqr.inc'; // for qrHtml()
    
    $vKeyPw = $vKeyPw ? u\b64decode($vKeyPw) : openssl_random_pseudo_bytes(51);
    $vKeyE = u\cry($anonymizing ? 'r' : 'R', $vKey, FALSE, $vKeyPw);

    $id = db\get('id', 'admins', compact('uid'));
    $can = db\get('can', 'admins', compact('uid'));
    $can |= r\adminCanBit('v');
    db\updateOrInsert('admins', compact(ray('id uid vKeyE can')));
    $pw = u\b64encode($vKeyPw);

    return $showQr ? qr\html($pw, '', t('%PROJECT SuperAdmin')): $pw;
  }
  
  /**
   * Call a function for each co-branding partner for whom the current account is a customer.
   * @param function(coA, custA, custCode) $func: the function to call, with three parameters:
   *   coA: company account
   *   custA: customer account
   *   custCode: the company's identifier for the customer
   */
  public function eachPartner($func) {
    $sql = 'SELECT r.main, r.code FROM u_relations r JOIN users u ON u.uid=r.main WHERE r.other=:id AND r.:IS_CUSTOMER AND u.:IS_PARTNER ORDER BY r.code';
    $res = db\q($sql, ['id' => $this->id])->fetchAllKeyed();
    foreach ($res as $main => $code) $func(r\acct($main), $this, $code);
  }
  
  /**
   * Return specified account's profile picture, with markup
   * NOTE: We assume the current user has permission to see this photo
   * @param bool $unique: should the markup force reloading the image
   * @return: markup to display the account's picture (with a default image if none)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoHtml($small = FALSE, $unique = FALSE) {
    $a = $this;
    if (test()) return $a->agentA->photo;
    return '<div id="user-picture"><img src="' . $a->photoSrc($small, $unique) . '" alt="profile picture" /></div>';
  }
  
  /**
   * Return src attribute for specified account's profile picture, no markup, just the src
   * NOTE: We assume the current user has permission to see this photo
   * @param bool $small: use thumb instead of photo
   * @param bool $unique: should the markup force reloading the image
   * @return: value for the src attribute to display the account's picture (with a default image if none or not permitted)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoSrc($small = FALSE, $unique = FALSE, $qr = FALSE) {
    global $mya, $base_url;
    $a = $this;
    
    if ($unique) $unique = '&t=' . now();
    $thing = $small ? 'thumb' : 'photo';
    if ($qr or $a != $mya) { // not our own photo (anybody can see a company's photo, otherwise encode)
      $qid = $a->co ? "qid=$a->mainQid" : ('code=' . u\cryRay(ray('qid sid qr cardCode', $a->mainQid, session_id(), $qr, $a->cardCode)));
    } else { $qid = ''; }
      
    return "$base_url/account-$thing/$qid$unique";
  }
  
  /**
   * Get and store SSN verification from 3rd party (in the background).
   * ssn step is marked done if all of the following are true:
   * . supplied last name (dba or legal) matches
   * . at least one other piece of name (dba or legal) matches, that has at least 4 letters
   * . birth date matches
   * . person is not dead
   * @param bool $force: redo search
   * @return the data
   */
  public function ssnCheck($force = FALSE) {
    $a = $this;
    if (!$a->hasFid) return t('No SSN yet.');;
    $fid = $a->vsecure['federalId'];
    if ($fid == '000000000') return t('Nonmember SSN.');
    if ($fid == '999999999') return t('SSN is a test.');
    if ($a->ssnData and !u\starts($a->ssnErr, SSN_TIMEOUT_MSG) and !$force) return $a->ssnData;
    
    $max = 5;
    for ($i = 0; $i < $max; $i++) {
      if ($ssnData0 = u\ssnLookup($a->federalId) and !mb_strpos($ssnData0, 'RequestTimedOutException')) break;
    }
    if ($i == $max) return $a->ssnErr(SSN_TIMEOUT_MSG . t(' on %max tries.', compact('max')));

    if (substr($ssnData0, 0, 1) == '<') try {
      $xml = simplexml_load_string($ssnData0);
      $json = u\jsonize($xml);
      $ssnData = u\dejsonize($json);
    } catch (\Exception $er) { }
    
    if (!nn($ssnData) or !is_array($d = nni($ssnData, 'searchResults')) or nni($ssnData, 'ResultCount') + 0 <= 0) { // 0 for tests, <=0 for failure
      return $a->ssnErr(t('No SSN data available: ') . pr($ssnData0));
    }
    unset($ssnData['searchResults']['ssn']); // has first 5 digits of SSN -- don't store it
    $a->update(compact('ssnData'));
    if (nn($d['deathsearchresults'])) return $a->ssnErr(t('The person is dead (?).'), $ssnData);
    
    list ($first1, $last1, $mid1) = u\parseName($a->fullName, TRUE);
    list ($first2, $last2, $mid2) = u\parseName($a->legalName, TRUE);
    foreach (ray('first1 last1 first2 last2') as $k) $$k = mb_strtolower($$k);
    
    $Ls = $Fs = $DOBs = [];
    $names = nn($d['ssnnames']['ssnname']);
    if (nni($names, 'lastname')) $names = [$names]; // handle case of just one name
    
    foreach ($names as $one) {
      $one = (object) $one;
      $name = u\ssnName($one, $F, $M, $L);
      $Ls[] = mb_strtolower($L);
      if (mb_strlen($F) > 1) $Fs[] = mb_strtolower($F);
      if ($M) foreach (explode(' ', mb_strtolower($M)) as $F) {
        if (mb_strlen($F) > 1) $Fs[] = $F;
      }
      if ($dob = nni($one, 'dob')) $DOBs[] = strtotime($dob);
    }
    
    if (!array_intersect([$last1, $last2], $Ls)) return $a->ssnErr(t('Last name does not match.'), $ssnData);
    if (!array_intersect([$first1, $first2, $mid1, $mid2], $Fs)) return $a->ssnErr(t('First name does not match.'), $ssnData);

    if ($DOBs) {
      if (!in($a->dob, $DOBs)) return $a->ssnErr(t('bad birthdate'), $ssnData);
    } else {
      $a->ssnErr(t('Cannot verify birthdate'), $ssnData);
      $a->setRisk('dobOff'); // nothing to compare, so don't ask member to retype dob
    }
    
    $a->stepDone('verifyid');
    $a->stepDone('ssn');
    return $a->ssnData;
  } 
    
  /**
   * Try to transfer funds from payer to payee for a pre-approved payment.
   * @param int $payee: record ID of recipient -- expected to be an active account, 
   *   but payer can be a not-yet-activated account (to be invoiced) for gifts to CG
   * @param numeric $amount: payment amount
   * @param string $desc: description of payment
   * @param assoc $data: extra data for transaction or invoice
   * @param int $recursId: record ID of related record in tx_timed (if any)
   * @return a txRet object
   */
  public function payApproved($payee, $amount, $desc, $goods, $data = [], $recursId = NULL) {
    $a = $this;
    $payeeA = r\acct($payee);
    u\EXPECT($payeeA->ok, 'inactive recipient');
    if ($payeeA->legalName != CGF_LEGALNAME) u\EXPECT($a->ok, 'inactive payer'); // not-yet-active accounts can be invoiced for gifts to CG
    $shortfall = NULL;

    $DBTX = \db_transaction();
    if ($a->ok) {
      for ($i = 0; ; $i++) { // try again if getting funds is likely to help
        $z = be\transfer('payment', $a, $payeeA, $amount, $desc, $goods, $data, $recursId);
        if ($z->ok) {unset($DBTX); return $z;}
        if ($i > 0 or !$shortfall = nni($z->subs, 'shortfall') or $shortfall > $a->creditLine) break; // try just once to fill shortfall
        $a->getFunds($shortfall, t('to cover your %amt payment request', 'amt', u\fmtAmt($amount)));
        if ($a->avail($goods) < $amount) break;
      }        
    } else $z = be\txRet(FALSE, 'you wait');

    $data['status'] = TX_APPROVED;
    $z2 = be\invoice($payeeA, $this, $amount, $desc, $goods, $data, $recursId);
    unset($DBTX);
    
    return $z2->ok ? be\txRet(TRUE, "$z->msg|when resolved", $z2->subs) : $z; // use error message from payer's point of view
  }

  /**
   * Return the account's total gifts to the Common Good.
   */
  function totalGifts() {
    return db\sum('amt', 'txs_noreverse', 'uid1=:id AND uid2=:CGID AND :IS_GIFT', ['id' => $this->id ]);
  }
  
  /**
   * Set ssnData to an error message and maybe more
   * @param string $s: the error message
   * @param assoc $ssnData: whatever ssn Data we received from the lookup service
   */
  public function ssnErr($s, $ssnData = []) {
    $this->update('ssnData', $res = $ssnData + [SSN_ERR_INDEX => $s]);
    return $res;
  }

  /**
   * Say whether receiving the given amount will require an SSN where we don't have it yet.
   */
  public function needSsnFor($amt) {
    $a = $this;
    if ($a->co or $a->hasFid) return FALSE;
    if (!$res = db\get('SUM(amt) AS tot, COUNT(eid) AS cnt', 'txs_noreverse', 'created>:jan1 AND uid2=:myid AND type<>:E_BANK', ray('jan1 myid', strtotime(date('Y-01-01')), $a->id))) return FALSE;    
    extract($res);
    return !r\no1099k($tot);
  }
  
  /**
   * Record latest account access
   */
  public function accessed() {
    global $channel;
    $a = $this;
    $info = ray('access lastip', now(), $_SERVER['REMOTE_ADDR']);
    if ($channel == TX_WEB) {
      $info['login'] = now();
      if ($a->ok) r\ipok($a->id);
    }
    $a->update($info);
  }
  
  /**
   * Return the rough (physical) location of the entity with the given account (city, state, non-US country).
   * @param bool $complete: if TRUE, include the street address
   */
  public function location($complete = FALSE) {
    $a = $this;
    $country = realCountry($a->country);
    $result = [];
    if ($complete) $result[] = (string) $a->address; // (string) in case address is NULL
    $result[] = $a->city;
    $result[] = $a->st . (($complete and $a->zip) ? ' ' . $a->zip : '');
    if ($a->country != R_COUNTRY_ID) $result[] = mb_strtoupper($country);
    foreach ($result as $key => $value) if ($value === '') unset($result[$key]);
    return join(', ', $result);
  }
  
  private function hasVSecure($fld) {return (nni($this->vsecure, $fld, '') !== '');}

  public function isMe($uid) {return ($uid == $this->id or $uid == $this->jid);} // same account
  public function codeHash() {return u\hash($this->cardCode());}
  public function o($k) {return $this->{'o_' . $k};}
  public function api($etc = '') {return $this->website ? tr(CO_API_URL, 'website etc', $this->website, $etc) : '';}
  public function lastTx($where = 1, $subs = []) { return r\Tx::lastTx($this->uids, $where, $subs); }
  public function lastTxDesc() {return ($tx = $this->lastTx) ? t(' (Last tx: %dt)', 'dt', fmtDt($tx->created)) : '';}
  public function isBank() {return r\isBank($this->id);}
  public function nameAndEmail() {return [$this->email => $this->fullName];}
  public function nameAndQid() {return "$this->fullName ($this->mainQid)";}
  public function firstCo() {return db\get('fullName', 'u_relations r INNER JOIN users u ON r.main=u.uid', 'r.permission>0 AND r.other=:id AND u.:IS_CO ORDER BY r.created LIMIT 1', ['id' => $this->id]);}
  public function adminables() {
    $res = ray(B_ADMINABLE . ($this->admMakeAdmin ? ' admin' : ''));
    return array_values($this->isCtty ? array_intersect($res, ray(B_CTTY_BITS)) : array_diff($res, ray(B_CTTY_BITS)));
  }
  public function setDftAppCans() {foreach (ray(CO_APP_DFTS) as $i) $this->setCoBit(APP_CANS + $i);}
  public function eq($a2) {return ($a2 and $this->id == $a2->id and $this->agentId == $a2->agentId);}

} // end of class

/**
 * Return an account object for the described account.
 * call by:
 *   r\acct()       (returns current account)
 *   r\acct($uid)
 *   r\acct($main, $agent)
 *   r\acct($main, $agent, $error)
 *   r\acct($email)
 * @param int $uid: account uid
 * @param int $main: main account uid
 * @param int $agent: agent uid
 * @param string $email: email address for the account
 * @param string $error: error message, if any
 * @return the appropriate account object (FALSE if none)
 */
function acct($uid = '', $agent = '', &$error = '') {
///    print_r("acct($uid, $agent, $error)<br>");
  u\EXPECT(!is_array($uid), 'array uid'); // otherwise hangs (at least for a drupal field array)
  global $mya;
  if (!$uid) return $mya ?: (!$error = 'There is no current account.');
  
  if (mb_strpos($uid, '@')) {
    $uid = db\get('uid', 'users', 'email=:email ORDER BY :IS_CO', ['email' => u\cry('P', $uid)]);
  } elseif (FALSE and preg_match('/[0-9]( |-|\\)) ?[0-9]{4}/', $uid)) {
    $uid = db\get('uid', 'users', 'phone=:phone ORDER BY :IS_CO', ['phone' => u\cry('P', u\fmtPhone($uid, '+n'))]);
  }
  if (!$ua = r\Acct::viable($uid, $agent, TRUE)) return FALSE;
  return new r\Acct($ua); // the only place we call new r\Acct() with a flat array (meaning an existing account)
}

/**
 * Return an account object for the agent of the given account.
 */
function agent($uid = '') { $a = r\acct($uid); return $a ? $a->agentA : NULL; }

/**
 * Set the current account.
 * If there is no account signed in, set the agent also.
 * @param mixed $myid: the new account or account ID (if NULL, sign out. If '', get from sessions)
 * @param assoc $sta: (MODIFIED) if passed, gets ['uid'] set, to sign the account in
 * NOTE: $sta works only before displaying a page, not before redirecting (\session_regenerate does not appear to work).
 * @return the new account
 */
function setAcct($myid = '', &$sta = NULL) {
  global $mya, $boxId;
  global $user;
  global $channel; 
  if (is_object($myid)) list ($myid, $agentId) = [$myid->id, $myid->agentId]; else $agentId = FALSE;
  if ($sta) $sta['uid'] = $myid;
  w\uncacheSubmenus();
  $boxId = NULL;

  if (is_null($myid)) { // sign out
    $user = obj('uid', 0);
    w\svar('myid', NULL); w\svar('agentId', NULL);
    return $mya = NULL;
  }

  if ($myid) w\svar('myid', $myid); else $myid = w\svar('myid') ?: (w\svar('agentId') ?: 0);
  if (!$agentId and !$agentId = w\svar('agentId')) w\svar('agentId', $agentId = $myid);
  if ($sid = session_id()) db\update('sessions', ray('uid acct ssid', $agentId, $myid, $sid), 'ssid');
  w\svar('agentId', $agentId); w\svar('myid', $myid); // redo in case we're testing
  if (empty($user)) $user = obj('uid', $myid); else $user->uid = $agentId;
  if (!$myid) return $mya = NULL;

  if ($a = r\acct($myid, $agentId)) { // we get NULL here when current account is deleted
    if ($a->proSe or !$a->admin) $a->accessed(); // admin access doesn't count
  } else { $a = setAcct(NULL); }
  
  if ($a) $a->boxId();
  return $mya = $a;
}

function taskSteps($task) {return $task ? u\consta('s', $task) : '';}
function allSteps() {return array_flip(array_keys(ray(S_ALL)));} // point step bit names to bit numbers
