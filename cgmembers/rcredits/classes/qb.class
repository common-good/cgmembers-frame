<?php
use CG as r;
use CG\Util as u;
use CG\Web as w;
use CG\DB as db;
use CG\Backend as be;

use QuickBooksOnline\API\DataService as qbDS;
use QuickBooksOnline\API\Data as qbData;
use QuickBooksOnline\API\Facades as qbFacades;

const LOAN_CAT = 11150; // cat of "Other Loans" asset category
const QSEND_TEST = FALSE; // outputs instead of sending
const MAX_QCNT = 0; // maximum number of txs to send (whether testing or not)
const CC_PCT = .0199; // credit card processor percentage fee
const CC_PT = .49; // credit card processor per-transaction fee

const QB_TYPES = 'Bank, Other Current Assets, Accounts Receivable, Fixed Assets, Other Assets, Credit Card, Accounts Payable, Other Current Liabilities, Long Term Liabilities, Equity, Income, Cost of Goods Sold, Expenses, Other Income, Other Expense'; // not yet used

// https://help.developer.intuit.com/s/error-resolver

/**
 * @file
 * Common Good QB class
 *
 * Manage our API at https://developer.intuit.com (sign in)
 
 Refer the steps below for regular Oauth integration steps for SAAS apps.For a desktop app either you need to have a web component or a receiver configured for Oauth callback handling or use hard coded tokens.Refer bold section below.Steps for integration with QBO-Please use sandbox QBO accounts ondeveloper.intuit.comfor testing or development.Please refer the following blog post for integrating with QBO API:
 https://developer.intuit.com/blog/2015/04/16/a-3-step-guide-to-getting-started-with-intuit-developer
 https://developer.intuit.com/hub/blog/2016/04/25/quick-start-to-quickbooks-online-rest-api-with-oauth1-0Status 
 
 page for APIs: https://intuitdevelopergroup.statuspage.io/
 
 Go to https://developer.intuit.com/. Create an app on our IDG platform for the QBO v3 apis.You will get a set of consumer key, consumer secret and app token.Set the above keys in the config of your code. Then implement Connect to Quickbooks button:
 https://developer.intuit.com/docs/0100_quickbooks_online/0100_essentials/0001_develop_quickbooks_apps/0004_authentication_and_authorization/connect_from_within_your_app
 
 Then run the code. Your client who has the QBO company can then authorize your code/website to access his QBO company data using Connect to Quickbooks button.Or if you have a sandbox company, then you authorize the code to access your sandbox company.NOTE: For sandbox testing, you need to use dev app keys and sandbox base url.For live/prod qbo company testing, use prod app keys and prod base url after doing a private publish as mentioned below.Go to your app-Prod tab- enter all urls and save. Then get the prod keys from Keys tab under Prod tab of the app. Please refer to:
 https://developer.intuit.com/v2/blog/2014/10/20/changes-to-ipp-app-tokenshttps://developer.intuit.com/blog/2014/10/24/intuit-developer-now-offers-quickbooks-sandboxes
 
 OR if you to connect to your own file, you can generate the oauth tokens from playground. Go to your app-Click Test Connect to Oauth-Intuit Anywhere tab-Set time duration in seconds for 180 days and get the access token and secret for your app and company by right clicking on the page and doing a view source.You will then set of access token and access token secret and realmid/companyid to make api calls for their QBO company which is valid for 180 days.To 'renew tokens', you can call reconnect api after 150 days or do Connect to Quickbooks after 180 days to get new tokens.https://developer.intuit.com/docs/0100_quickbooks_online/0100_essentials/0085_develop_quickbooks_apps/0004_authentication_and_authorization/oauth_management_apiNOTE for desktop apps/automated service type apps-
 
 There is no way to bypass the Oauth process. You will have to do it at least once to make api calls using the Oauth tokens. So, if you have a desktop app/service then you can use Postman or any sample apps we have, add the app keys and then get the Oauth tokens. These are valid for 180 days. Then use app keys and oauth tokens them in your code.


@Dany Yacoub:â€‹ anyway you need to authorize via UI at least one time, then you can refresh an access token in a background. https://developer.intuit.com/docs/00_quickbooks_online/2_build/10_authentication_and_authorization/10_oauth_2.0

According to https://help.developer.intuit.com/s/article/Validity-of-Refresh-Token:
Refresh Token life: 100 days, but may die within "about a day".
Access Token life: 1 hour.
So we get a new refresh token in the background every 4 hours.
 
 */

require_once DRUPAL_ROOT . '/../vendor/autoload.php';
const QB_CHUNK = 500; // how many records to read at once

class QB {
  private $ds = NULL;
  private $helper = NULL;
  private $refreshed = FALSE;
  
  /**
   * Return a new QB object.
   * @param string $creds: the company's credentials for QBO
   * @param bool $refresh: automatically refresh the access token when creating
   */
  public function __construct($creds, $refresh = TRUE) {
    list ($clientId, $secret) = ray($creds);
    
    $ds = $this->ds = qbDS\DataService::Configure([
      'auth_mode' => 'oauth2',
      'ClientID' => $clientId,
      'ClientSecret' => $secret,
      'RedirectURI' => isPRODUCTION ? BASE_URL . '/qbo' : 'https://cg4.us/qbo.php',
      'scope' => 'com.intuit.quickbooks.accounting', // com.intuit.quickbooks.accounting or com.intuit.quickbooks.payment
  //    'baseUrl' => (isPRODUCTION or isSTAGE) ? 'Production' : 'Development',
      'baseUrl' => 'Production',
    ]);

    $ds->throwExceptionOnError(TRUE);
    $this->helper = $ds->getOAuth2LoginHelper();
    if ($refresh) $this->refresh();
  }
  
  /**
   * Refresh the Access Token -- unless it was refreshed very recently.
   */
  public function refresh() {
    global $channel;

    if ($this->refreshed or test()) return;
    extract(just('rToken rExpires realmId lastRefresh', getv('qboRefresh') ?: [], NULL));
// FAILS   if (now() < $lastRefresh + HOUR_SECS / 2) return; // no need to refresh if done within the past half hour
    
    if ($rExpires > time() + 60) { // at least a minute left to refresh
      $token = $this->helper->refreshAccessTokenWithRefreshToken($rToken);
      $token->setRealmId($realmId); // required (stupid though that is)
      $this->ds->updateOAuth2Token($token);
      $this->setRefreshToken($token, $realmId);
    } elseif ($channel == TX_WEB) { // out of time to refresh (or first time), so reauthorize
      return w\softErr('qbo lost');
    } else return r\tellAdmin(t('Connection lost to QBO'), ray(t('Alert'), tr('qbo lost')));
  }

  /**
   * Get a new refresh token from the given token and realmId, and remember it.
   */
  private function setRefreshToken($token, $realmId) {
    $ray = ray('rToken rExpires realmId lastRefresh', $token->getRefreshToken(), strtotime($token->getRefreshTokenExpiresAt()), $realmId, now());
    setv('qboRefresh', $ray); // store refreshToken so we don't have to re-authorize each time
    $this->refreshed = TRUE;
  }
  
  /**
   * Reauthorize (foreground only)
   *   If called with no GET parameters, provide a link to get a refresh token from scratch.
   *   Otherwise set the refresh token, given the authorization parameters in $_GET
   * @param $_GET: authorization parameters OR nothing (to redirect and get authorization parameters)
   */
  public function auth() {
    extract(just('code realmId', $_GET, NULL));

    if (!$code) return w\say(t('Click <%a>here</a> to set QBO Refresh Token.', '_a', w\atag($this->helper->getAuthorizationCodeURL())));

    $token = $this->helper->exchangeAuthorizationCodeForToken($code, $realmId);
//    delv('qboRefresh'); // force refresh even if it just happened
    $this->setRefreshToken($token, $realmId);
    return w\sayEmpty('QBO Refresh Token has been set.');
  }

  /**
   * Create a financial account.
   * @return the account object.
   */
  public function createAccount($name, $qbParentId, $qbType, $description = '') {
    foreach (ray('name qbType') as $k) if (!$$k) return w\err(t('Field %k is required.', compact($k)));
    $this->refresh();
//    if ($res = $this->ds->query("SELECT * FROM Account WHERE Name='$name'", 1, 1)) return w\err('Account %name already exists.', compact('name'));
    $info = ray('Name AccountType', $name, $qbType);
    $res = $this->ds->query("SELECT * FROM Account WHERE Name='UNUSED'", 1, 1);
    if ($res and $acctObj = $res[0]) {
      foreach ($info as $k => $v) $acctObj->$k = $v;
    } else {      
      $qbAcct = qbFacades\Account::Create($info);
      $acctObj = $this->ds->Add($qbAcct);
    }
    
    if ($error = $this->ds->getLastError()) {
/**/  echo "The Status code is: " . $error->getHttpStatusCode() . "\n";
/**/  echo "The Helper message is: " . $error->getOAuthHelperError() . "\n";
/**/  echo "The Response message is: " . $error->getResponseBody() . "\n";
/**/  die('in qb.class');
    }
    
//    $res = $this->ds->query(tr("SELECT * FROM Account WHERE Id='%id'", $acctObj->Id), 1, 1))
    if ($qbParentId) $acctObj->ParentRef = $qbParentId;
    $acctObj->Description = $description;
    return $this->ds->Update($acctObj);
  }

  /**
   * Return a list of active Income and Expense accounts, keyed by id.
   */   
  public function getAccounts() {
    $this->refresh();
    $ray = $this->getRows('*', 'Account', 'Active ORDERBY FullyQualifiedName'); // '*' so we don't loop through records twice

    $res = [];
    foreach ($ray as $acct) {
      extract(just('Id FullyQualifiedName Description Classification', $acct));
      $type = strtr($Classification[0], ray('R E A L', 0,1,2,3));
      if (!strhas($FullyQualifiedName, 'UNUSED')) $res[$Id] =  "$type: " . str_replace(':', ': ', $FullyQualifiedName) . "\t$Description";
    }

    asort($res); // NOTE: Intuit won't sort by account type ("Classification")
    foreach ($res as $k => $v) $res[$k] = 'IEAL'[$v[0]] . substr($v, 1);
    return $res;
  }
  
  /**
   * Send the latest transactions in CG's various accounts to QBO.
   * Strategy: Create a journal entry for each CG transaction.
   *
   * Except: Create a single journal entry for each ACH batch -- see sendBankTxs() below
   * AND a separate journal entry for each credit card purchase -- see sendCCTx() below.
   * Creating an entry just for the net of the ACH batch allows easy reconciliation with the bank and CC Processor.
   * So these journal entries do not include an increase in a Dollar Pool bank account and Dollar Pool liability
   * because those other functions do that.
   *
   * A standard income, expense, or transfer for CG itself results in a 2-line journal entry (for example, increase in assets and income).
   * A non-member transaction would normally increase the dollar pool (and dollar pool liability),
   * but that is handled separately, as describe here above.
   * Fiscal sponsor fees increase the number of journal entry lines by 4 (from 2 to 6): Sponsee -> CG and Sponsored Donations -> Sponsorship Fees
   * Credit card charges increase the number by 4 again: Sponsee -> CG and [increase the (negative) Tx Fee Reimbursement Expense and the (positive) Sponsored Tx Expense]
   * This is all driven by the accounting categories (cat field) chosen manually or by be\setCat().
   *
   * Accounting NOTE: to increase an account, CREDIT income and liability, DEBIT expense and asset (maybe think of expenses and assets as being negative income and liabilities).
   */
  public function sendTxs($end = NULL) { // usually call only from sendBankTxs
    global $testQbTxs;
    
    $start = strtotime('7/1/2021');
    if (!isset($end)) $end = db\max('deposit', 'txs JOIN txs2 USING (xid)', ':IS_QBOK'); // don't go beyond latest cgFund# export, in case some txs have both a cg# and a cgFund#
    $this->refresh();
    $cnt = 0;
    $sql = 'SELECT DISTINCT uid2 FROM txs WHERE :IS_CC AND uid1=:UID_OUTER AND created BETWEEN :start AND :end';
    $uids = db\q($sql, compact(ray('start end')))->fetchCol(0); // sponsored only for CC processing
    $uids = array_unique(array_merge($uids, r\catUids()));

    $txs = be\getTxs($uids, $start, $end, ray('includeSelfTxs catsOnly', TRUE, TRUE));

    foreach ($txs as $entries) {
      extract(just('xid description created banking cat2 uif2 uid2 name', $entries[0]));
      if (!$this->isNew("cg#$xid")) break;

      if ($banking) {
        if (r\acct($uid2)->sponsored) $description .= ': ' . strtolower(u\word9(db\get('category', 'tx_cats', ray('id', $cat2)), ': '));
      } else $description = strip_tags("$description [$name]"); // strip hyperlinked "various" transactions dumping buckets into CGID

      $info = ray('DocNumber PrivateNote TxnDate', "cg#$xid", $description, fmtDt($created, 'yyyy-MM-dd'));
      $qbTx = new qbData\IPPJournalEntry($info);

      foreach ($entries as $e) $this->addTxLine($qbTx, $e, $description);

      if (QSEND_TEST) {
/**/    debug($qbTx);
      } else {
        if (test()) $testQbTxs[] = $qbTx; else
        $this->ds->Add($qbTx);
        r\setQbOk($xid);
      }
      $cnt++; if (MAX_QCNT and $cnt >= MAX_QCNT) break;
    }
    list ($xid1, $xid9) = $txs ? [$txs[0][0]['xid'], $xid] : ['', ''];
//    r\tellAdmin(t('QBO export complete'), ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9));
    w\say(t('QBO export complete: ') . pr(ray('count xid1 xid9', sizeOf($txs), $xid1, $xid9)));
  }

  /**
   * Send the latest batches of CG bank transfers to QBO.
   * Then send all other transactions up to the latest deposit date (and no further! lest a transaction get marked done before it gets transferred as a deposit)
   */
  public function sendBankTxs($end = NOW + 1) {
    global $testQbTxs;
    
    $start = strtotime('7/1/2021');
    $this->refresh();
    $tx0 = ray('uid1 cat1 uid2 cat2', '', '', UID_BANK, db\get('id', 'tx_cats', "nick='POOL'")); // same asset and liability categories for all entries
    $cnt = 0;

    $sql = <<< X
      SELECT deposit, bankTxId, (MIN(txid)<0 AND SUM(1)=1) AS reversal, SUM(amount) AS amt, SUM(1) AS txCnt,
      SUM(IF(amount<0, 0, amount)) AS amtIn, SUM(IF(amount<0, 0, 1)) AS cntIn,
      SUM(IF(amount<0, amount, 0)) AS amtOut, SUM(IF(amount<0, 1, 0)) AS cntOut
      FROM txs2 x2 JOIN tx_hdrs h USING (xid)
      WHERE deposit BETWEEN :start AND :end AND bankAccount IS NOT NULL
      AND NOT h.:IS_QBOK AND bankTxId IS NOT NULL
      GROUP BY deposit, bankTxId
X;

    $q = db\q($sql, compact(ray('start end')));

    while ($row = $q->fetchAssoc()) {
      extract($row);
      if ($cnt == 0) $dt1 = $deposit;
      $DocNumber = "cgFund#$deposit";
      if (!$this->isNew($DocNumber)) break;
      
      $PrivateNote = $reversal ? t('reversal') : ($txCnt > 1 ? t('ACH batch') : t('single bank transfer'));
      
      if ($txCnt > 1) $PrivateNote .= t(': IN %in (%cntIn), OUT %out (%cntOut)', 'in out cntIn cntOut', 
          u\fmtAmt($amtIn), u\fmtAmt($amtOut), $cntIn, $cntOut);
      $effectiveDt = $bankTxId ? substr($bankTxId, 0, 10) : u\nextBizDay(u\nextBizTm($deposit)); // at some point all relevant bankTxIds will be set and this will be simpler
      $TxnDate = fmtDt($effectiveDt, 'yyyy-MM-dd');
      $qbTx = new qbData\IPPJournalEntry(compact(ray('DocNumber PrivateNote TxnDate')));

      $this->addTxLine($qbTx, $tx0 + ray('amt', $amtIn + $amtOut), $PrivateNote);
      
      if (QSEND_TEST) {
/**/    debug($qbTx);
      } else {
        if (test()) $testQbTxs[] = $qbTx; else
        $this->ds->Add($qbTx);
        $this->sendTxs($deposit); // transfer all non-bank aspects of all transactions up through this deposit date/time
        db\q('UPDATE tx_hdrs h JOIN txs2 x2 USING (xid) SET h.flags=(h.flags|(1<<:B_QBOK)) WHERE x2.deposit=:deposit', compact('deposit')); // AFTER sendTxs()!!
      }
      $cnt++; if (MAX_QCNT and $cnt >= MAX_QCNT) break;
    }

    list ($dt1, $dt9) = $cnt ? [fmtDt($dt1), fmtDt($deposit)] : ['', ''];
//    r\tellAdmin(t('QBO Ctty Fund export complete'), compact(ray('cnt dt1 dt9')));
    w\say(t('QBO Ctty Fund export complete: ') . pr(compact(ray('cnt dt1 dt9'))));
    if (!db\exists('txs2', 'deposit>:mdt1', ray('mdt1', u\monthDay1()))) w\err(t("WARNING: There are no bank transfers completed yet in the current month, so you will need to export to QBO again before last month's definitive financial reports can be produced."));
  }
  
  /**
   * Add a CG transaction entry pair to a QBO Journal Entry as a debit/credit pair (or possibly two pairs).
   * @param obj $qbTx: the QBO JournalEntry object to add to
   * @param assoc $e: the CG transaction entry to handle
   * @param string $desc: transaction description
   * @param assoc $e0: first entry pair in the transaction
   * @param 
   */
  public function addTxLine($qbTx, $e, $desc) {
    extract(just($flds = 'xid amt uid1 uid2 cat1 cat2 flags noBank', $e));

    $processorNick = $uid2 == CGID ? 'PROCESSOR' : 'FBO-PROCESSOR'; // QBO makes automatic PayPal reconciliation impossible, so we lose little by separating these

    if ($uid1 == UID_OUTER and $noBank and $cat1 != CAT_CG2CG and (!$cat1 or $cat1 = r\nick2cat($processorNick))) { // no bank account in the CG system and payer category not set yet (because UID_OUTER is not owned by CG)
      if (u\getBit($flags, B_CC)) { // payment by cc
        $ccFee = u\sign($amt) * round(CC_PT + CC_PCT * abs($amt), 2); // add a couple lines for the processing fees CG pays
        u\EXPECT($uid2 == CGID or db\exists('tx_entries', ray('xid entryType', $xid, E_XFEE)), t('CC payment with no CC fee (xid#%xid): %desc', compact(ray('xid desc'))));
        $e['cat1'] = r\nick2cat($processorNick);
      } else {
        $e['cat1'] = r\nick2cat(r\acct(UID_BANK)->mainQid); // check/wire/directACH in or out of the Ctty Fund bank account
      } // either way, UID_OUTER will map to Dollar Pool Liability (POOL)
    }

    foreach ([2, 1] as $i) if ($e["cat$i"]) { // do recipient first (if you change this, fix how $amt negation is handled)
      if ($i == 1) $amt = -$amt; // payer loses the amount
      foreach (ray('uid cat') as $k) $$k = $e["$k$i"];

      $uidNick = $uid == UID_OUTER // UID_OUTER only when called from sendCCTx()
      ? ($cat == CAT_CG2CG ? r\acct(UID_BANK)->mainQid : 'POOL') // CC not allowed for loans
      : (((r\hasCats($uid) or $uid == UID_BANK) and $qid = r\acct($uid)->mainQid) ? $qid : 'LOANFUND');

      $this->addJLine($qbTx, $uidNick, -$amt, $desc);
      if ($cat != CAT_CG2CG) $this->addJLine($qbTx, $cat, $amt, $desc);
    }

    if (isset($ccFee)) { // save the CC processor fees for AFTER the main transaction
      $this->addJLine($qbTx, 'TX-FEE', -$ccFee, $desc);
      $this->addJLine($qbTx, 'PROCESSOR', $ccFee, $desc); // fees CG pays for CC processing do not affect dollar pool liability, so post them to the normal processor account
    }
  }

  /**
   * Add a Journal Entry Line to the Journal Entry Transaction.
   * @param IPPJournalEntry $qbTx: (MODIFIED) the QB JournalEntry object to add lines to
   * @param int $id: CG's internal accounting category nickname or ID (in tx_cats)
   * @param numeric $Amount: amount to credit the account
   * @param string $Description: transaction description
   */
  private function addJLine(&$qbTx, $id, $Amount, $Description) {
    $PostingType = $Amount < 0 ? 'Debit' : 'Credit';
    $Amount = abs($Amount);
    $AccountRef = r\qbCat($id);
    u\EXPECT(!empty($AccountRef), t('empty AccountRef for cat=%cat in tx %txid', 'cat txid', $id, $qbTx->DocNumber));
    $DetailType = 'JournalEntryLineDetail';
    $$DetailType = new qbData\IPPJournalEntryLineDetail(compact(ray('PostingType AccountRef')));
// (not needed and doesn't work)   if ($id == LOAN_CAT) $$DetailType->Entity = $this->getEntity($Description);
    $line = compact(ray("Description Amount DetailType $DetailType"));
    $qbTx->Line[] = new qbData\IPPLine($line);
  }

  /**
   * In a given Journal Entry, change every occurrence of a given AccountRef to a given other AccountRef, identified by CG tx_cats IDs.
   * @param int $oldCat: the old CG tx_cats ID
   * @param int $newCat: the new CG tx_cats ID
   * @param int/string $id: the Journal Entry ID or CG transaction ID
   * @return the number of changes made (NULL if the transaction does not exist)
   */
  public function changeCat($oldCat, $newCat, $id) {
    if (is_numeric($id)) { // xid
      $cnt = 0;
      db\q('UPDATE tx_entries SET cat=:newCat WHERE xid=:id AND cat=:oldCat', compact(ray('oldCat newCat id')));
      foreach (ray('cg ccCharge cgFund') as $k) $cnt += ($this->changeCat($oldCat, $newCat, "$k#$id") ?: 0);
    } else { // QBO DocNumber
      if (!$qbTx = $this->getQbTx($id)) return NULL;

      foreach (ray('old new') as $k) ${$k . 'AcctRef'} = r\qbCat(${$k . 'Cat'});
      $cnt = 0;

      foreach ($qbTx->Line as $i => $line) {
        if ($line->JournalEntryLineDetail->AccountRef == $oldAcctRef) {
          $qbTx->Line[$i]->JournalEntryLineDetail->AccountRef = $newAcctRef;
          $cnt++;
        }
      }

      if ($cnt) {
        $qbTx = qbFacades\JournalEntry::update($qbTx, ray('sparse Line', TRUE, $qbTx->Line));
        if (test()) $testQbTxs[] = $qbTx; else
        $res = $this->ds->Update($qbTx);
      }
    }
    
    w\say("Made $cnt changes");
    return $cnt;
  }
   
  /**
   * If the transaction has already been sent to QBO, show an error message and return FALSE (else return TRUE).
   * @param string $id: the journal entry identifier
   */
  private function isNew($id) {
    if (test() or QSEND_TEST) return TRUE;
    if (!$this->get('Id', 'JournalEntry', "DocNumber='$id'")) return TRUE;
    if (u\starts($id, 'cgFund#')) return TRUE; // ignore if QBO already has this bank transfer (no doubt caused by a crash while processing transactions up to that deposit date)
//    $xid = substr($id, strpos($id, '#') + 1);
//    if (TRUE or $xid <= 163686) {r\setQbOk($xid); return TRUE;} // delete this line and the preceding after 7/1/2022
    w\err(t('Transaction %id has already been transferred! Stopping...', compact('id')));
    return FALSE;
  }
  
  private function getEntity($desc) {
    $nm = strtr(strstr($desc, '['), ray('[ ]', '', ''));
    return $this->get('Id', 'Customer', tr("DisplayName='%nm'", compact('nm')));
  }
  
  /**
   * Return the QBO transaction corresponding to the given DocNumber.
   * @param string $id: the QBO DocNumber (transaction identifier)
   * @param string $objName: the QBO Object name (defaults to JournalEntry)
   * @return the QBO transaction (NULL if the transaction does not exist)
   */
  public function getQbTx($id, $objName = 'JournalEntry') {
    $this->refresh();
    if (!$res = $this->ds->query("SELECT * FROM JournalEntry WHERE DocNumber='$id'", 1, 1)) return w\say(t('Entry %id does not exist.', compact('id')));
    return $res[0];
  }
  
  public function delQbTx($id, $objName = 'JournalEntry') {
    if (!$qbTx = $this->getQbTx($id, $objName)) return FALSE;
    $this->ds->Delete($qbTx);
    w\say(t('QBO entry %id deleted.', compact('id')));
    return TRUE;
  }    
  
  /**
   * Return a field value from one QB record.
   */
  public function get($fld, $tnm, $where = '') {
    $res = $this->getRow($fld, $tnm, $where);
    return ($res ? $res[$fld] : NULL);
  }
  
  /**
   * Return one record array from QB.
   */
  public function getRow($flds, $tnm, $where = '') {
    if (!$rows = $this->getRows($flds, $tnm, $where, 1)) return NULL;
    return (array) $rows[0];
  }
  
  /**
   * Return an array of QB record objects.
   * Not allowed in $where: 0, -1, TRUE, >
   */
  public function getRows($flds, $tnm, $where = '', $max = 999999) {
    $this->refresh();
    $where = ($where and $where !== TRUE) ? "WHERE $where" : '';
    if (!$cnt = $this->ds->query("SELECT COUNT(*) FROM $tnm $where")) return NULL;
    $rows = [];
    for ($i = 1; $i <= min($max, $cnt); $i += QB_CHUNK) {
      $rows += $this->ds->query("SELECT * FROM $tnm $where", $i, min(QB_CHUNK, $max - sizeOf($rows)));
    }
    if ($flds != '*') foreach ($rows as $i => $row) $rows[$i] = just($flds, $row); // QBO API doesn't handle field list
    return $rows;
  }

  /**
   * Create a QB account for a new fiscal sponsee.
   */
  public function makeSponsee($name0, $qid) {
    $name = $name0 . ' ..' . substr($qid, -3);
    $qbAcct = $this->createAccount($name, r\qbCat('SPONSORED'), 'Bank', tr('FBO %name0 (fiscal sponsorship)', compact('name0')));
    $this->updateAccts();
    $id = db\get('id', 'tx_cats', 'externalId=:qbId', ray('qbId', $qbAcct->Id));
    db\update('tx_cats', ray('id category show nick', $id, 'A: Sponsored: ' . $name, TRUE, $qid));
  }

  /**
   * Import QB accounts into tx_cats.
   */
  public function updateAccts() {
    $qbAccts = $this->getAccounts();
    $id = 0; // tracks each record as we insert or update it
    $redo = !db\exists('tx_cats');
    if (!$redo and $diff = array_diff(db\col('externalId', 'tx_cats', '`show`'), array_merge([0], array_keys($qbAccts)))) { // if we deleted accounts in QBO, unshow them here ([0] for internal-only)
      db\q('UPDATE tx_cats SET `show`=0 WHERE externalId IN (:diff)', compact('diff'));
      w\err(t('These cats have been deleted in QBO, so they have been hidden here too: ') . join(', ', $diff));
    }
      
    foreach ($qbAccts as $externalId => $category) {
      list ($category, $description) = explode("\t", $category);
      $info = compact(ray('externalId category' . ($description ? ' description' : '')));
      if ($redo) { // building tx_cats from scratch (don't do this on production db!!)
        $id += 100;
        db\insert('tx_cats', $info + compact('id'), 'id');
      } else { // updating tx_cats from QBO
        if ($id0 = db\get('id', 'tx_cats', compact('externalId'))) { // category alread exists here, so just update it
          $id = $id0;
          db\update('tx_cats', $info + compact('id'), 'id');
        } else { // category doesn't exists here yet, so choose an id for it (ideally alphabetical) and insert
          if ($nextId = db\min('id', 'tx_cats', 'id>:id', compact('id'))) {
            $id = round(($id + $nextId) / 2, 0);
            if (db\exists('tx_cats', compact('id'))) {
              $id = db\max('id', 'tx_cats') + 1;
              say(t('Maybe change id (order) of new category "%category" (temporary id %id) to be roughly alphabetical before using it.', compact(ray('id category'))));
            }
          } else $id = round($id + 100, -2);
          db\insert('tx_cats', $info + compact('id'), 'id');
        }
      }
    }
  }

}
