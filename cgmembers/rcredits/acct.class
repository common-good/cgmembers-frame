<?php
namespace CG;
use CG as r;
use CG\DB as db;
use CG\Backend as be;
use CG\Util as u;
use CG\Web as w;
use CG\Admin as a;

/**
 * @file
 * %PROJECT Account class
 */

define('SSN_TIMEOUT_MSG', t('No data returned from ssnLookup'));
 
class Acct {
  public $id; // the account's record id
  public $agentId; // record id (in the agent's regional server) of whoever is acting on behalf of the account
  public $qo; // qid object
  
  private static $perms = []; // permissions for all acct objects, indexed by id and agent
  private static $rs = []; // account records for all acct objects, indexed by id
  
  /**
   * Instantiate (create or retrieve) a member account for transactions and/or contact
   * @param mixed $info (either assoc or array):
   *   (1) an assoc: initial field values for the account, to be created in the database, including at least one of these:
   *     'uid' the record id
   *     'phone' is contact phone (in standard +ddddddddddd format) OR
   *     'number' is cell phone (in standard +ddddddddddd format -- use for phone also) OR
   *     'email' is email address
   *     (This function assumes that the field values not sufficient to identify an existing user)
   *   (2) a flat array of user table IDs: [uid, agent] where uid is the main account and agent is the agent's id
   */
  function __construct($info = []) {
    $a = $this;
    if (!is_numeric(key($info))) { // u\isAssoc($info)) { // specifying field values
      $a->createNew($info); // create new db record
    } else { list($a->id, $a->agentId) = $info; } // called from r\acct()
    $a->qo = r\qo($a->id, $a->proSe ? '' : $a->agentId);
  }    

  /**
   * Create a new account record in the database.
   * @param assoc $info: array of field values for new account (only fullName is required)
   */
  private function createNew($info) {
    global $mya;
    $a = $this;
    extract($info);

    extract(just('fullName flags state zip created number uid region', $info,
      [NULL, 0, 0, NULL, now(), NULL, NULL, NULL]));
    u\setDft($legalName, $fullName);
    u\setDft($email, mb_strtolower(u\randomString(10, 'word')) . '@' . EMAILX);
    u\setDft($community, r\communityUid($zip));
    u\setDft($login, $created);
    u\setDft($access, $login);
    u\setDft($name, r\uniqueName($fullName, $info));
    $country = R_COUNTRY_ID;

    if (isset($phone)) $phone = u\fmtPhone($phone, '+n');
    if (!is_numeric($state)) $state = r\stateNum($state); // allow US state abbreviations
    $co = ($flags & u\bit(B_CO));
    
    if (empty($region)) $region = empty($zip) ? -r\uidRegion($community) : -r\region($country, $state, $zip);
    $record = empty($uid) ? compact('name') : compact('uid', 'name');

    $DBTX = db_transaction();
    $uid = r\regionalInsert('users', 'uid', $record, $region);
    u\EXPECT($uid != 0, 'zero regionalinsert');
    $a->reread(); // set all real fields
    list ($a->id, $a->agentId) = array($uid, $mya ? $mya->agentId : $uid); // finish creating the object

    u\setDft($cardCode, r\cardCode(r\qid($uid)));
    u\setDft($emailCode, r\cardCode(r\qid($uid)));

    foreach (ray('number region') as $k) unset($info[$k]);
    foreach (ray('phone email pass fullName legalName flags state country community created login access emailCode cardCode') as $k) if (isset($$k)) $info[$k] = $$k; // things we may have added or changed

    $a->update($info); // this is a lot easier to do after saving the record
    if (!$a->member) $a->setTask($co ? 'co' : 'person');
    
    unset($DBTX); // commit
  }

  /**
   * Setup acct variables, returning FALSE on error.
   * @param id/qid $id: the account's record id or qid (DEFAULT to myid)
   * @param id/qid $agent: the agent's record id or qid (DEFAULT to same as $id)
   * @param string $error: (RETURNED) the error message, if any
   * @param bool $test: <this is only a test, do not die on error>
   * @return [$id, $agent] where id and agent are actual record IDs
   */
  public static function viable($id00, $agent0='', &$error='', $test = TRUE) {
///       print_r("Acct::viable($id00, $agent0, $error, $test)<br>");
    if (is_numeric($id00) and is_numeric($agent0)) return [$id00, $agent0];
    $id0 = $id00;
    if (strpos($id0, AGT_MARK)) list ($id0, $agentCode) = explode(AGT_MARK, $id0); // new company qid format

    if ($error = u\EXPECT(compact(ray('id0 agent0')), 'zid|qid|assoc empty|id|qid', $test)) return FALSE;
    if ($error = u\EXPECT((bool) $id0, 'null uid in new r\Acct()', $test)) return FALSE;
    //    if ($error = u\EXPECT(!(strpos($id0, R_AGENT_MARK) and $agent0), 'agent already specified in qid', $test)) return FALSE;
    list ($id, $agent) = u\isZid($id0) ? [$id0, $agent0 ?: $id0] : r\qo($id00, $agent0)->ia; // handle

    if (u\isQid($agent0)) {
      list ($agent, $zot) = r\qo($agent0)->ia;
      if ($error = u\EXPECT($agent == $zot, 'agent agent not allowed', $test)) return FALSE;
    }

    $got = (bool) self::getRecord($id); // read the record into cache
    if ($error = u\EXPECT($got, 'That account does not exist.', $test)) return FALSE; // don't use t() here (many calls)

    if (isset($agentCode)) $agent = r\qo($id0 . AGT_MARK . $agentCode)->agent; // new company qid format

    if ($error = u\EXPECT($id and $agent, "Missing acct property: [$id, $agent]", $test)) return FALSE;
    return [$id, $agent];
  }
  
  private static function getRecord($uid, $reread = FALSE) {
///       print_r("getRecord($uid, $reread)");
    if (nni(self::$rs, $uid) and !$reread) return self::$rs[$uid];
    if (!$row = db\get('*', 'users', compact('uid'))) { // no such record here
      if (TRUE) return FALSE; // not foreign either
      // contact other server here, for a subset of the record
    }
    
    return self::$rs[$uid] = (object) $row;
  }

  /**
   * Read in the account record, if we haven't yet.
   * This function should be called before any reference to self::$rs[$this->id] (except in contructor).
   * @param bool $force: reread even if we already have an account record (used only externally)
   */
  public function reread($force = FALSE) {
    if (!nni(self::$rs, $this->id) or $force) self::getRecord($this->id, TRUE);
  }
  
  /**
   * Return the value of the specified field that is not a simple property of the acct class.
   * This function reads the account record from the database if it hasn't been read yet.
   * Many of these fields are slightly tweaked fields from the users table (for example, unserialized or decrypted).
   * @param string $field: name of field value to get
   * @return the value if it exists, else NULL
   */
  public function __get($field) {
    $a = $this; $uid = $a->id;
    $uidSub = compact('uid');
    $a->reread(); // make sure record has been read in

    if (u\starts($field, 'j_')) { // concatenate joint fields
      $field = substr($field, 2);
      return $a->o($field) . ($a->jid ? ' & ' . $a->jA->o($field) : '');
    }

    if (u\starts($field, 'o_')) { // ignore joinedness of the account ("own" account)
      $field = substr($field, 2);
    } elseif ($field != 'balance') { // don't add together in a joint account, even though it's a joint field (same in both)
      if (in($field, JOINT_FLDS) and $a->jid) return round(($a->o($field) ?: 0) + ($a->jA->o($field) ?: 0), 2); // sum joint fields
      if (in($field, MASTER_FLDS) and $a->slave) return $a->jA->o($field); // master only
    }

    // From here down, everything should be for "own" account
    $nick = $a->getNick($field); // modifies $field and sets nick to 'can' for flag bits
    if ($nick == 'can') return $a->can(u\consta('b', $field));
    if ($nick == 'rel') return $a->proSe ? NULL : $a->relFld($field);
    if ($nick == 'coy') return $a->co ? $a->coFld($field) : NULL;
    if ($nick == 'ctt' and $field != 'cttyA') return $a->cttyA->can(u\consta('b', substr($field, 4))); // ctty bit

    if (property_exists($obj = nni(self::$rs, $a->id, NULL), $field)) { // actual database field?
      $res = $obj->$field; // get the raw data, then handle any encryption
      /// Not currently used    if ($nick == 'raw') return $res;
      if ($field == 'balance') return db\get('balance', 'users', $uidSub); // make sure this field is always au courant
      if ($field == 'email') return u\decryIf('P', nn($obj->email));
      if ($field == 'phone') return u\decryIf('P', nn($obj->phone));
      if (in($field, 'data secure vsecure') and !is_array($res)) { // aggregated field not yet decrypted and arrayed
        if (!$res) return [];
        if ($field != 'data') $res = u\decry('S', $res);
        return (self::$rs[$a->id]->$field = unserialize($res));
      }
      return $res; // normal field (no encryption)
    }
    
    switch ($field) { // handle pseudo-fields (every case returns)
      case 'mainQid': return $a->qo->mainQid;
      case 'isAdmin2': return (bool) ($a->agentA->flags & u\bit(B_ADMIN2)); // not ->can() included by cAdmin etc. (see note in can())
      case 'phoneDash': return u\fmtPhone($a->phone, '-');
      case 'st': return r\realState($a->state, $a->country);
      case 'agentA': return r\acct($a->agentId);
      case 'proSe': return ($a->id == $a->agentId);
      case 'qid': return $a->qo->qid;
      case 'uids': return $a->jid != 0 ? [$a->id, $a->jid] : [$a->id];
      case 'bestName': return $a->shortName ?: $a->fullName;
      case 'isCtty': return ($a->id < 0); // or ($a->id == $a->community); (regions are communities too)
      case 'isRegion': return (substr($a->name, -1, 1) == '.');
      case 'cttyA': return r\acct($a->community);
      case 'region': return r\uidRegion($a->id);
      case 'regionA': return r\acct($a->region);
      case 'regionName': return ($regionA = $a->regionA) ? $regionA->fullName : (PROJECT . ' ' . db\get('name', 'r_regions r INNER JOIN r_states s ON s.abbreviation=r.st', 's.country_id=:US_COUNTRY_ID AND r.region=:reg', ['reg' => $a->qo->region]));
      case 'url': return ($a->isRegion ? '' : strtr($a->fullName, [PROJECT=>'', ' '=>'']) . $a->st . '.') . CG_DOMAIN; // applies only to communities (->cttyUrl)
      case 'lastTx': return $a->lastTx();
      case 'legalNameDpy': return str_replace('_', ' ', $a->legalName); // for u\parseName of names like Jay di_Fiori
      case 'owns': return !$a->risk('rents');
      case 'creditLine': return -$a->floor;
      case 'hasFid': return $a->hasVSecure('federalId');
      case 'hasId': return ($a->hasFid or $a->hasVSecure('altId'));
      case 'hasDob': return $a->hasVSecure('dob');
      case 'closed': return ($a->activated and !$a->ok); // data[newAccount] has new qid, if any
      case 'hasBank': return $a->hasVSecure('bankAccount');
      case 'lowSecurity': return u\n2ai(substr($a->created, -5, 5), 3); // result is 3 chars long
      case 'inviteCode': return $a->mainQid . $a->lowSecurity;
      case 'isCanonic': return ($a->id >= 0 and $a->id < CANONIC_ACCTS);
      case 'slave': return ($jid = $a->jid and $jid < $a->id); // slave in a joint account
      case 'jA': return $a->jid ? r\acct($a->jid) : NULL;
      case 'masterA': return $a->slave ? $a->jA : $a;
      case 'helperA': return $a->helper ? r\acct($a->helper) : '';
      case 'foody': return db\get(':U_FOODY', 'users u', $uidSub);
      case 'iclub': return ($a->id < 0 or strhas($a->fullName, t('Investment Club')));
      case 'iclubId': return db\get('clubid', 'r_stakes', $uidSub);
      case 'trialco': return ($a->co and $a->depends);
      case 'prefsSet': return !is_null($a->o_minimum); // preferences have been set at least once
      case 'hasCustomers': return db\exists('r_relations', 'main=:id AND :IS_CUSTOMER', ['id' => $a->id]);
      case 'superAdmin': return ($a->agentId == 1) ?: (test() and $a->admin and $a->agentA->name == 'abeone');
      case 'bankInfo': return (!$routing = substr($a->bankAccount, 4, 9)) ? NULL
                                : db\get('*', 'r_banks', 'route=:routing', compact('routing'));
      case 'shouter': return db\exists('u_shouters', $uidSub);
      case 'tempPhotoFilename': return r\pic("$a->mainQid.jpg");
      case 'ssnErr': return is_array($a->ssnData) ? nni($a->ssnData, SSN_ERR_INDEX) : FALSE;
      case 'hasPhoto': return db\exists('r_photos', $uidSub);
      case 'photo': return ($res = db\get('photo', 'r_photos', $uidSub)) ? u\decry('H', $res) : '';
      case 'thumb': return db\get('thumb', 'r_photos', $uidSub) ?: '';
      case 'changes':
        $chFlds = 'oldValue,newValue';
        foreach ($rows = db\rows($chFlds, 'r_changes', $uidSub) as $i => $row) {
          foreach (ray($chFlds) as $k) if ($type = u\crypted($row->$k)) $rows[$i]->$k = u\decry($type, $row->$k);
        }
        return $rows;
      default: return $a->getSpecial($field); // member of an aggregate field: set up caches and get value
    }
  }

  /**
   * Return the 3-character field prefix, if any, and remove it from the field name.
   */
  private function getNick(&$field) {
    $nick = substr($field, 0, 3); // possibly meaningful prefix (ctt if the prefix is ctty)
    if (in($nick, 'can raw rel coy') and $field != 'rawChanges') {
      $field = lcfirst(substr($field, 3));
      return $nick;
    }
    if (in($field, REL_FLDS . ' ' . REL_FLAGS)) return 'rel';
    if (in($field, CO_FLDS)) return 'coy';
    if (in($field, B_LIST . ' ' . B_CTTY_BITS)) return 'can';
    return $nick;
  }

  /**
   * Cache the set of special fields of which the given field is a member.
   * @param mixed $field: name of a field within an aggregate field (data/secure/vsecure)
   * @return the field value
   * @throw warning if the field does not exist
   */
  private function getSpecial($field) {
    $a = $this;
    foreach (ray('data secure vsecure') as $k) {
      if ($a->special($field, strtoupper($k))) {
        $set = $a->$k ?: []; // special field $k gets cached by call to $a->$k
        $result = nni($set, $field);
        if ($k == 'vsecure' and u\crypted('V', $result)) $result = u\decry('V', $result);
        return $result; // must be separate line from $a->set (PHP bug)
      }
    }
    
    trigger_error(t('Account pseudo-field "%field" is undefined.', compact('field')), E_USER_WARNING);
    return NULL;
  }
  
  /**
   * Say whether the given field(s) is/are the specified kind of special.
   * @param mixed $fields: array or space-delimited list of fields (one or more)
   * @param string $specialType: name of space-delimited list of special fields of a certain type.
   * @return <at least one of $fields is in the $specialType list>
   */
  private function special($fields, $specialType) {
    $specials = constant("{$specialType}_FLDS");
    return is_array($fields) ? (bool) array_intersect($fields, ray($specials))
      : (strhas($fields, ' ') ? (bool) array_intersect(ray($fields), ray($specials))
        : u\inList($fields, $specials)); // be efficient, if just one field
  }

  /**
   * Return the value of a company field.
   */
  private function coFld($k) {
    $a = $this;
    if (!$a->co) return NULL;
    $subs = ray('uid', $a->id);
    if (!$info = db\get('*', 'r_company', 'uid=:uid', $subs)) {
      db\insert('r_company', $subs, 'uid');
      return nni($subs, $k); // NULL unless $k is 'uid'
    } else return $info[$k];
  }
  
  /**
   * Set one or more company fields
   */
  private function setCo($info) {db\updateOrInsert('r_company', $info + ['uid' => $this->id], 'uid');}
  
  /**
   * Return the value of a relationship field for this compound account.
   */
  private function relFld($k) {
    $a = $this;
    if ($a->proSe) return NULL;
    if (in($k, REL_FLAGS)) {
      $flags = r\relation('flags', $a->id, $a->agentId);
      return u\getBit($flags, u\consta('b', $k));
    } else return r\relation($k, $a->id, $a->agentId); // not $a->qid because it depends on otherNum
  }
  
  /**
   * Set a relation field.
   * Current account is expected to be r\acct($main, $other).
   * @param assoc $info: fields and values to change (if relations record does not exist, create it)
   *   $info may include bit names for the flags field
   */
  public function setRel($info) {
    $a = $this;
    u\EXPECT(!$a->proSe, 'setting relation on proSe');
    if (!is_array($info)) $info = rayy(func_get_args());

    if ($set = just(REL_FLAGS, $info)) {
      $flags = $a->relFld('flags') + 0;
      foreach ($set as $k => $v) {
        u\setBit($flags, $k, $v);
        unset($info[$k]);
      }
      $info += compact('flags');
    }
    if ($reid = $a->relFld('reid')) {
      return db\updateOrInsert('r_relations', $info + compact('reid'), 'reid');
    } else $a->newRelation($info + ray('other', $a->agentId));
  }      
  
  /**
   * Set the company categories.
   */
  function setCategories($cats) {
    $a = $this;
    $DBTX = db_transaction();
    db\del('r_user_industries', 'uid=:id', ['id'=>$a->id]);  // out with the old
    foreach ($cats as $iid) db\insert('r_user_industries', ray('uid iid', $a->id, $iid)); // in with the new
    unset($DBTX); // commit
  }  
  
  /**
   * Return a printable (scrambled) invitation card code or gift coupon code 
   * @param int $iCode: sequence number (0 to 35^3-1)
   * @see r\iCardAcct()
   */
  public function iCardCode($iCode = 0) {
    $a = $this;
    list ($region, $tail) = $a->qo->parse();

    $b = u\lpad(decbin(u\a2n($region)), ILEN_REGION);
    $b .= u\lpad(decbin(u\a2n($tail)), ILEN_TAIL);
    $b .= u\lpad(decbin(u\ai2n($a->lowSecurity)), ILEN_SECURITY);
    $b = u\rotateBits($b, ($iCode + 1) * (bindec(substr(R_INVITE_KEY, 0, 31)) % strlen($b)));
    $b = u\xorBits($b, substr(R_INVITE_KEY, -strlen($b)));
    return u\n2ai(bindec(substr($b, 0, ILEN_DIV)), 5) . u\n2ai(bindec(substr($b, ILEN_DIV)), 5) . u\n2ai($iCode, -1);
  }

  /**
   * Return the entire account object or just certain fields.
   * @param string $just: space-delimited list of fields to return (all raw fields, if empty)
   * @param bool $own: <return just the account's own field values, even if it is a joint account> (always true if $just == '')
   * Note: the returned object does not include uid -- haven't figured out why.
   */
  public function account($just = '', $own = TRUE) {
    $a = $this;
    $a->reread(); // make sure we have read the record from the db
    if (!$just) return nni(self::$rs, $a->id);

    foreach (ray($just) as $k) $res[$k] = $own ? $a->o($k) : $a->$k;
    return (object) $res;
  }

  public static function _clear() {self::$perms = self::$rs = [];}
  
  /**
   * Return the next available uid in the specified region.
   */
  public static function nextId($region = '') {
    u\EXPECT($region <= 0, 'non-negative region in nextId');
    return r\newUid(-($region ?: r\serverUid()));
  }
  
  /**
   * Update the saved record in the database with the given data. For joint accounts, update partner too.
   * Call by:
   *   update($info); OR
   *   update($fields, $value1, ...)
   * @param assoc $info: data to update
   * @param string $fields: space-delimited list of field names
   * @param mixed $value1 (etc): new values for those fields
   * @return: TRUE if update succeeds, FALSE if update fails
   */
  public function update($info) {
    $a = $this;
    if (!is_array($info)) $info = rayy(func_get_args());
    
    u\EXPECT(!isset($info['savings']), 'archaic savings field');
    if ($a->jid and $jInfo = just(MASTER_FLDS, $info)) {
      list ($a2, $a1) = u\order($a->slave, $a, $a->jA); // set $a1 master, $a2 slave

      $jInfo2 = array_fill_keys(ray(MASTER_FLDS), 0);
      unset($jInfo2['achMin']); // no change to slave achMin
      $a2->update1($jInfo2);
      $a1->update1($jInfo);
      if (!$info = justNOT(MASTER_FLDS, $info)) return TRUE; // fall through if something else to update
    }
    return $a->update1($info);
  }

  /**
   * Update the account record in the database (with no special treatment of joint accounts).
   */
  public function update1($info) { // public only for testing
    global $mya;
    $a = $this;

    if (!is_array($info)) $info = rayy(func_get_args());
    if ($bits = just(B_LIST, $info)) {
      $a->setBit($bits);
      $info = justNOT(B_LIST, $info);
    }
    
    foreach (just(REL_FLDS . ' ' . REL_FLAGS, $info) as $k => $v) {$a->setRel($k, $v); unset($info[$k]);}
    if ($coFlds = just(CO_FLDS, $info)) {$a->setCo($coFlds); $info = justNOT(CO_FLDS, $info);}

    if ($a->ok or $a->activated or nni($info, 'altId')) $a->recordChanges($info); // record changes if member is (or was) active or verifying ID (so we have a record of who verified it)
    foreach (just('hasBank', $info) as $k => $v) {$a->setRisk($k, $v); unset($info[$k]);}

    foreach (ray('photo thumb') as $k) if (isset($info[$k])) $a->updatePhoto($info, $k);
    foreach (ray(PSECURE_FLDS) as $k) if (isset($info[$k])) $info[$k] = u\cry('P', $info[$k]);
    if (isset($info['pass']) and $info['pass'] !== '') $info['pass'] = r\passHash($info['pass']);
    if (isset($info['dob'])) $a->update('yob', $info['dob'] === '' ? '' : date('Y', $info['dob'])); // remember birth year for demographics
    u\preray($info, self::$rs[$a->id]); // cache the new field values (before doing special fields)
    
    foreach (ray('data secure vsecure') as $special) {
      if (isset($info[$special])) {
        $sFlds = $info[$special]; // can be '' for no data
      } elseif ($sFlds = just(constant(strtoupper($special) . '_FLDS'), $info)) {
        $sFlds += $a->$special; // replace existing values with update info
      } else continue;

      if ($special == 'vsecure' and $sFlds) {
        if ($a->activated) foreach ($sFlds as $k => $v) {
          if (!u\crypted('V', $v)) $sFlds[$k] = u\cry('V', $v); // hyper-encrypt when activated (when auto-access to EIN no longer needed). This and recordChanges are the ONLY places we do u\cry('V', ) !!
        }
        if (array_key_exists('bankAccount', $sFlds)) $a->setRisk('hasBank', (bool) $sFlds['bankAccount']);
      }
      self::$rs[$a->id]->$special = $sFlds;
      $sFlds = serialize($sFlds);
      $info[$special] = ($special == 'data' or !$sFlds) ? $sFlds : u\cry('S', $sFlds);
    }

    $info = justNOT(SECURE_FLDS . ' ' . VSECURE_FLDS . ' ' . DATA_FLDS, $info); // don't pass these
    return $info ? db\update('users', $info + ['uid' => $a->id], 'uid') : TRUE;
  }

  /**
   * Set photo or thumb.
   */
  public function updatePhoto(&$info, $k) {
    $a = $this;
    $data = $info[$k];
    $isThumb = ($k == 'thumb');
    if ($data or $isThumb) { // setting
      db\updateOrInsert('r_photos', ['uid' => $a->id, $k => $isThumb ? $data : u\cry('H', $data)], 'uid');
      if (!$isThumb and !test()) { // always create a new thumb when we create or change the photo
        $factor = ($a->co ? 2 : 1) * THUMB_FACTOR;
        list ($w, $h) = $a->co ? CO_ASPECT : FACE_ASPECT;
        $img = u\alterImg(imagecreatefromstring($data), $w * $factor, $h * $factor);
        $thumbInfo['thumb'] = u\img2string($img, $a->co ? 100 : 50);
        $a->updatePhoto($thumbInfo, 'thumb');
      }
    } else {db\del('r_photos', 'uid', $a->id);} // delete record if deleting photo
    unset($info[$k]);
  }

  /**
   * Record memorable changes being made to an account record.
   * @param assoc $info: all changes being made
   */
  private function recordChanges($info) {
    global $mya;
    $a = $this;

    $newChanges = justNOT(R_HIDE_CHANGES, $info); // see if there are any changes to remember
    foreach ($newChanges as $field => $v) {
      $ak = $a->$field;
      if ($v == $ak or (is_numeric($v) and is_numeric($ak) and $v + 0 == $ak + 0)) continue; // don't record if no change

      $oldValue = $a->cryIf($field, is_array($a->$field) ? serialize($a->$field) : ('' . $a->$field), TRUE);
      $newValue = $a->cryIf($field, is_array($v) ? serialize($v) : '' . $v);
      $record = ray('uid created field oldValue newValue changedBy', $a->uid, now(), $field, $oldValue, $newValue, $mya ? $mya->agentId : 0);
      db\insert('r_changes', $record); // add a r_changes record for each changed field
    }
  }
	
  /**
   * Encrypt if appropriate
   */
  private function cryIf($k, $v, $old = FALSE) {
    $a = $this;
    foreach (ray('psecure vsecure secure') as $secure) {
      list ($type, $flds) = [ucfirst($secure[0]), constant(strtoupper($secure) . '_FLDS')];
      if (in($k, $flds)) {
        if ($old and $type == 'V') $v = nni($a->vsecure, $k); // special case for possibly already-encrypted, inaccessible vsecure value
        return u\crypted($type, $v) ? $v : u\cry($type, $v);
      }
    }
    return $v;
  }
		
  /**
   * Create a new relationship record for the current account (as "main") relating to some agent.
   * NOTE: Assume no other company agent for this company is trying to create a relation at the same time.
   * @param assoc $info: field values
   * @return: the record ID of the new relationship record
   */
  function newRelation($info) {
    u\EXPECT($info['other'] or nni($info, 'data'), 'missing other in new relation'); // placeholder for "other" ok if there's data
    foreach (ray(REL_FLAGS) as $k) if (array_key_exists($k, $info)) { // array_key_exists not nn or isset (might be NULL)
      u\setBit($info['flags'], $k, $info[$k]);
      unset($info[$k]);
    }
    $info['created'] = now();
    return r\regionalInsert('r_relations', 'reid', $info + ['main' => $this->id], -$this->region);
  }

  /**
   * Create an agent number for the account's relation, if it's a relational account and doesn't have one yet.
   */
  public function setAgentNum() {
    $a = $this;
    if ($a->proSe or r\qo($a->qid)->agentCode) return;
    $otherNum = db\max('otherNum', 'r_relations', 'main=:main', ['main' => $a->id]) + 1;
    $a->setRel(compact('otherNum'));
    return $otherNum;
  }

  /**
   * Say whether the wanted transaction proof is really wrong, not just a delayed transaction with a cardcode that got changed.
   * @param string $proof: tx proof supplied by the app
   * @param string $wanted: proof we expected
   * @param int $created: transaction creation date/time
   * @return <the proof is really wrong>
   */
  public function badOldProof($proof, $wanted, $created) {
    $a = $this;
    $codeName = $a->proSe ? 'cardCode' : 'cardCode2';
    $code = $a->agentA->$codeName;
    //    $changes = $a->agentA->changes;
    $changes = db\rows('*', 'r_changes', 'uid=:id AND field=:fld AND created>:dt', ray('id fld dt', $a->agentId, $codeName,$created));

    foreach ($changes as $ch) if (u\hash(str_replace($code, u\decry('S', $ch->oldValue), $wanted)) == $proof) return false;

    return true;
  }

  /**
   * Return the account's name and qid, with a link to a fuller description.
   */
  public function linkedDesc() {
    global $base_url;
    $qid = "<a href=\"$base_url/change-account/acct=$this->mainQid\">$this->mainQid</a>";
    return "$this->fullName ($qid)";
  }
  
  /**
   * Set the bit in the given integer bit collection field to the given value.
   * If the requested bit is too high, "2" (or more) gets appended to the collection name
   * @param int $bit: number of bit to set (0 - 62)
   * @param bool $on: whether to set it ON or OFF
   * @return <successful>
   * @see also self::can()
   */
  public function setBit($bit, $on = TRUE, $field = 'flags') {
    $a = $this;
    
    list ($bits, $ons) = is_array($bit) ? [array_keys($bit), array_values($bit)] : [[$bit], [$on]];

    $n = $a->$field ?: 0;
    foreach ($bits as $i => $bit) {
      if ($field == 'flags' and !is_numeric($bit)) $bit = u\consta('b', $bit);
      $on = $ons[$i];
      if ($bit > B_MAX) $field .= 1 + floor($bit / (B_MAX + 1));
      u\setBit($n, $bit, $on);
      if ($field == 'flags' and nn(self::$perms['id'][$a->agentId])) {
        self::$perms['id'][$a->agentId][$bit] = $on;
      } // else can gets refreshed automatically next time can() is called
    }
    return $a->update($field, $n);
  }

  /**
   * Return a filename for the back of invitation cards (to print)
   */
  public function invitationBack() {
    $a = $this;
    $forCG = ($a->id == CGID and $a->superAdmin);
    $filename = ($a->co and !$forCG) ? 'InvitationCardsBackCo.pdf' : 'InvitationCardsBack.pdf';
    return 'http://cg4.us/doc/' . $filename;
  }

  /**
   * Return the amount not available, including draws from related accounts, depending on the purpose.
   * If there are fees for drawing from a related account, they are added to the amount needed.
   * If the account has permission to cash out while serving as an ATM their rewards amount will not limit them.
   * @param int $goods: (does not default, to make sure we know what we're doing)
   *   FOR_GOODS or FOR_NONGOODS: the amount of credit available for a purchase 
   *     (including credit lines)
   *   FOR_USD: the amount of credit available to trade for cash or US Dollars
   *     (not including credit lines and rewards)
   * @param float $need: the amount needed
   * @param bool $get: if true then draw from other accounts as needed, then say whether there is enough
   *                   if false (the default) just check and say whether we could get enough
   * @param acct $actor: account of the individual or company initiating the transaction
   * @return how much short this account is, of what's needed
   */
  public function shortfall($goods, $need = 0, $get = FALSE, $actor = NULL) {
    global $channel;
    $a = $this;
    // don't allow companies to spend rewards unless they have ATM permission and are exchanging r for USD
    if ($a->isCanonic) return 0;
    if ($a->co and COMPANY_FREEZE and $a == $actor and $a->coCan(CO_ATM) and $goods == FOR_USD) { $goods = FOR_GOODS; }
    $avail = $a->avail($goods);
    if ($avail >= $need) return 0; // plenty without drawing from other accounts
    if ($get) { $avail += $a->draw(($a->refill ? $a->minimum : 0) + $need - $a->balance); }
    else { $avail += $a->canDraw(); }
    return max(0, $need - $avail); 
  }
  
  /**
   * Return how much is available in this account for the given operation, without drawing on other accounts.
   * @param int $goods: purpose of the potential expenditure - see r\Acct::shortfall())
   * Do NOT take into account any advances from bank account (that would confuse the member's understanding of their credit line)
   */
  public function avail($goods = FOR_GOODS) {
    $a = $this;
    
    // no going into debt without permission
    if ($goods == FOR_USD or $a->cttyA->noneg or !$a->can(B_DEBT)) {
      $floor = max(0, $a->floor ?: 0) + ($a->giftPot ?: 0); // don't allow cashing out credit or gift cards
    } else {$floor = $a->floor;}

    return round($a->balance - $floor, 2);
  }
  
  /**
   * Return the amount this account can draw from other accounts.
   * Repairs the B_DRAWS bit if all such relations have ended.
   */
  private function canDraw() {
    $a = $this;
    if (!$a->can(B_DRAWS)) return FALSE;
    list($avail, $count) = $a->drawSourcesSummary();
    if ($count == 0) $a->setBit(B_DRAWS, FALSE); // doesn't really have any drawable accounts
    return $avail;
  }
  
  /**
   * Return a count of accounts we can draw from, and how much we can draw
   * @return ['avail'=>avail, 'count'=>count]
   */
  private function drawSourcesSummary() {
    $a = $this;
    return db\get("SUM(balance-IF(u.:IS_DEBT, floor, GREATEST(floor, 0))) AS avail, COUNT(*) as count",
                  "users u INNER JOIN r_relations r ON r.main=u.uid",
                  "r.other IN (:id, :jid) AND r.:IS_DRAW AND u.jid<>:id",
                  ['id' => $a->id, 'jid' => $a->jid ?: -1]);
  }
  
  /**
   * Return rows of accounts to draw from.
   * @return an array of records, each of which has uid and avail
   */
  private function drawSources() {
    $a = $this;
    $sql = <<< X
      SELECT u.uid, (balance-IF(u.:IS_DEBT, floor, GREATEST(floor, 0))) AS avail
      FROM users u INNER JOIN r_relations r ON r.main=u.uid
      WHERE r.other IN (:id, :jid) AND r.:IS_DRAW AND u.jid<>:id
X;
    return db\q($sql, ray('id jid', $a->id, $a->jid ?: -1));
  }
  
  /**
   * Draw the wanted amount from other accounts, usually to make a purchase and maintain a non-negative balance.
   * @param float $need: the amount wanted
   * @param string $why: purpose of transfer
   * @return float: the amount drawn
   */
  public function draw($need, $why = '') {
    $a = $this;
    if (!$a->can(B_DRAWS)) return 0;
    list ($from, $to, $auto) = array(t(' from '), t(' to '), t('automatic transfer'));
    $left = $need; // how much left to be drawn
    $q = $a->drawSources();
    foreach ($q as $row) {
      extract(just('uid avail', $row, 0));
      $amount = round(min($left, $avail), 2);
      if ($amount > 0) {
        list ($fromQid, $toQid) = [r\qid($uid), $a->mainQid];
        $for = [$auto . $from . $fromQid, $auto . $to . $toQid];
        list($ok, $message, $subs) = be\transfer('draw', $this, r\acct($uid), $amount, $for, FOR_NONGOODS);
        if ($ok) $left -= $amount;
        if ($left <= 0) break;
      }
    }
    $msg = $left == $need ? 'cannot draw' : 'drew';
    $msg = tr($msg, 'amount', u\fmtAmt($need - $left));
    r\notify($a->id, tr($msg, compact('why')));

    return round($need - $left, 2);
  }

  /**
   * Set or return the proxy for the person
   */
  public function proxy($priority = 1, $proxy = NULL) {
    $a = $this;
    $subs = ['person' => $a->id, 'priority' => $priority];
    if (empty($proxy)) { // return it
      return db\get('proxy', 'r_proxies', 'person=:person AND priority=:priority', $subs);
    } else { // set it
      db\del('r_proxies', 'person=:person AND priority=:priority', $subs);
      $subs['proxy'] = $proxy;
      db\insert('r_proxies', $subs);
    }
  }

  /**
   * Return the company's description.
   * @param bool $subtle: <make the categories a subtle last line>
   */
  public function coDesc($subtle = FALSE) {
    $a = $this;
    $uid = $a->id;
    $desc = u\parseUp($a->description);

    $sql = <<<EOF
      SELECT i.iid, i.industry FROM r_industries i 
      INNER JOIN r_user_industries ui ON ui.iid=i.iid 
      WHERE ui.uid=:uid ORDER BY i.industry
EOF;
    $cats = db\q($sql, compact('uid'))->fetchAllKeyed();
    $cats = empty($cats) ? '' : ($subtle
                                 ? ('<h3>Categories:</h3>' . join('<br>', $cats))
                                 : (t('Categories: ') . join(', ', $cats)) );
    
    return "$desc<br>$cats";    
  }
  
  /**
   * Mark two accounts joined (a joint account)
   * @param acct $b: the other account
   * Note we cannot split rewards and floor because they are recalculated in cron.
   */
  function join($b) {
    $a = $this;
    $fields = ray(MASTER_NUMERIC_FLDS);

    $DBTX = \db_transaction();
    foreach ([$a, $b] as $i => $ai) {
      $aj = $i == 0 ? $b : $a; // the other account
      $ai->update('jid', $aj->id);
      foreach ($fields as $k) $$k = nn($$k, 0) + ($ai->o($k) ?: 0);
    }
		
    $a->masterA->setBit(B_REFILL, $a->o_refill or $b->o_refill);
    $achMin = max($a->o_achMin, $b->o_achMin); // one of the $fields
    $minimum = $a->o_minimum + $b->o_minimum;
    $a->update(compact($fields)); // this sets master numeric fields to the sums, slave fields to zero
    unset($DBTX);
  }

  public function recomputeBalance() {
    $a = $this;
    $balance = db\sum('amount', 'tx_entries', 'uid IN (:uids)', ['uids'=>$a->uids]);
    if (empty($balance)) $balance = 0;
    $result = db\update('users', ray('uid balance', $a->id, $balance), 'uid');
    u\EXPECT($result == 1, "trouble updating balance");
    $a->reread();
  }
  
  /**
   * Remove all joins and join requests, except with the specified account record ID (if any).
   * @param acct $except: the joined account record ID for which NOT to delete join requests
   */
  function unjoinAllBut($except = FALSE) {
    $a = $this;
    
    $sql = 'UPDATE r_relations SET permission=:manage WHERE permission=:joint AND main=:id';
    $subs = ray('manage joint id', r\perm(B_MANAGE), r\perm(B_JOINT), $a->id);

    $DBTX = \db_transaction();
    if ($jid = $a->jid AND $jid != $except) { // unravel a consummated join
      $b = r\acct($jid); // ignore param (actual joined account will be unjoined and any join requests zapped)
      foreach ([$a, $b] as $ai) {
        $ai->update1('jid minimum', 0, max($a->o_minimum, $b->o_minimum));
        //        $ai->setBit(B_JOINED, FALSE);
      }

      $a->recomputeBalance();
      $b->recomputeBalance();

      if ($a->ok and $b->ok) { // no need to settle with closed or not-yet-open account
        $diff = $a->balance - $b->balance;
        $xfr = round($diff / 2, 2);
        list ($ok, $index, $args) = be\transfer('payment', $a, $b, $xfr, t('joint account settlement'), FOR_USD, ['force'=>1]);
        u\EXPECT($ok, t('Join account settlement failed for %p1 and %p2', 'p1 p2', $a->fullName, $b->fullName));
      }
    } elseif ($except) {
      $sql .= ' AND other<>:except';
      $subs += compact('except');
    }
    
    db\logSql(compact(ray('sql subs')));
    db\q($sql, $subs); // zap one or more joins (or requested joins) for this account
    unset($DBTX);
  }

  /**
   * De-activate the account for reasons of security or data integrity.
   * @param string $why: the reason for suspending (to tell member and staff)
   */
  public function suspend($why = '') {
    $this->setBit(B_OK, FALSE); // suspend the account
    if ($why) {
      r\message($this->id, 'account suspended', compact('why'));
      $notes = u\fmtDate() . ': ' . t('account suspended') . " $why\n" . nn($this->notes);
      $this->update(compact('notes'));
      r\tellAdmin('account suspended', ray('uid fullName why', $this->id, $this->fullName, $why));
    }      
  }
  
  /**
   * Return an auxiliary filename for the account.
   * @param bool $ideal: return the ideal normal name, even if the file does not exist (default FALSE)
   * @return: the relative file path (relative to Drupal)
   */
  public function photoFilename($ideal = FALSE) {
    return ($ideal or $this->hasPhoto)
      ? r\pic("$this->id-$this->cardCode.jpg")
      : ($this->co ? R_DFT_PICTURE_WIDE : R_DFT_PICTURE);
  }
  
  public function cardCode() {
    $field = $this->proSe ? 'cardCode' : 'cardCode2';
    return $this->agentA->$field;
  }

  /**
   * Create an rCard security code for the given account (either for an individual or a company agent).
   * @param acct $a: the account
   */
  function makeCardCode($newCode = '') {
    $a = $this;
    $qid = $a->qid;
    $aA = $a->agentA;
    $field = $a->proSe ? 'cardCode' : 'cardCode2';
    if ($aA->$field) r\badCard($qid, $aA->$field, t('making new card for %nm', 'nm', $a->fullName)); // (don't mark previous code bad if none)
//    if ($oldCode = $aA->$field) db\insert('r_bad', ray('qid code created', $qid, $oldCode, now()), 'created');
    $aA->update($field, $newCode ?: r\cardCode($qid)); // resave the secure fields
  }
    
  /**
   * Mark a membership step as completed.
   * @param string $step: a named step (see S_ALL, etc)
   * @param bool $done: whether to set the step done or not done
   * @param assoc $details: any details to report to the staff
   * @return the next step (FALSE if none)
   */
  function stepDone($step, $done = TRUE, $details = []) {
    $a = $this;
    
    $i = nni(r\allSteps(), $step, FALSE);
    u\EXPECT($i !== FALSE, 'bad step: ' . $step);
    $a->stepDoneForNow($step, $done);
    $a->setBit($i, $done, 'steps'); // done forever
    
    $nextStep = $a->nextStep();
    if ($done and empty($nextStep)) {
      $a->update('task', '');
      if (!$a->member) {
        r\tellCAdmin(t('New Member (%name)', ['name' => $a->fullName] + $details));
        $a->setBit(B_MEMBER);
        $a->update('tickle', now());
      }
    } elseif ($nextStep == 'partnerend' and count($a->stepsLeft) > 1) { // parnerend step should always be last
      $stepsLeft = $a->stepsLeft;
      unset($stepsLeft['partnerend']);
      $stepsLeft[] = 'partnerend';
      $a->update(compact('stepsLeft'));
    }
    return $nextStep;
  }

  /**
   * Remove the specified step from the current task (but don't mark it complete).
   */
  public function stepDoneForNow($step, $done = TRUE) {
    $a = $this;
    $stepsLeft = $a->stepsLeft();
    $p = array_search($step, $stepsLeft);
    $hasStep = ($p !== FALSE);
    if ($done and $hasStep) unset($stepsLeft[$p]);
    if (!$done and !$hasStep) $stepsLeft[] = $step;
    $a->update('stepsLeft', array_values($stepsLeft)); // renumber and update
  }

  /**
   * Return an array of the remaining steps in the given (or current) task.
   * @param string $task: the task of interest, such as card or voice (defaults to current task)
   * @see also $this->stepsLeft, which is the steps remaining in the current task, in order (possibly reordered)
   */
  public function stepsLeft($task = NULL) {
    $a = $this;
    
    if (!$steps = isset($task) ? ray(r\taskSteps($task)) : $a->stepsLeft) return [];
    $res = []; foreach ($steps as $k) if (!$a->stepIsDone($k)) $res[] = $k;
    if (!isset($task)) $a->update('stepsLeft', $res);
    return $res;
  }
    
  /**
   * Go to the next step
   * @param string $stepDone: the step just completed, if any
   * @param string $msg: basic message to display if completing or re-completing a step (defaults to "info saved")
   * @param string $msg: (RETURNED) a status message to display, if any 
   * @return the url of the next account-setup step ('', if no step)
   */
  public function nextStepUrl($stepDone = '', &$msg = NULL, $info = []) {
    $a = $this;
    u\setDft($msg, $stepDone ? 'info saved' : '');
    if ($a->closed) return 'summary';

    if ($stepDone) {
      $stepCounts = !$a->stepIsDone($stepDone);
      $a->stepDone($stepDone, TRUE, $info);
    } else { $stepCounts = FALSE; }
    
    if ($nextStep = ($a->task ? $a->nextStep() : FALSE)) {
      if ($stepDone and in($stepDone, r\taskSteps($a->task))) u\joins($msg, '|', 'step completed'); // say completed only when relevant
      return ray(S_ALL)[$nextStep] ?: "settings/$nextStep";
    }

    // no current task (nothing to be done next)
    if ($a->member and !$a->ok) {
      $a->update('stepsLeft task', '', '');
      $approval = $a->co ? 'company approval' : 'individual approval';
      u\joins($msg, '|', "setup complete|$approval|join thanks"); // show on display, not on done
    }
    $url = dirname($_SERVER['REQUEST_URI']);
    return $stepCounts ? 'summary' : ($url == '.' ? '' : $url); // go to summary page if this was the last step
  }

  public function setTask($task) {$this->update('task stepsLeft', $task, $this->stepsLeft($task));}
  public function stepIsDone($step) {return (bool) u\getBit($this->steps, nni(r\allSteps(), $step));}
  public function stepsDone($task) {
    foreach(ray(r\taskSteps($task)) as $step) if (!$this->stepIsDone($step)) return FALSE; 
    return TRUE;
  }
  public function nextStep() {return ($steps = $this->stepsLeft) ? $steps[0] : FALSE;}
  public function stepCount($task = NULL) {return count($this->stepsLeft($task));}

  /**
   * Check SSN during a signup step (normally on the verifyId step as soon as we get federalId, unless already verified)
   */
  public function verifySsnInBackground() {
    $a = $this;
    global $base_url;
    if (!$a->hasFid) return;
    if ($a->ssnData and !$a->ssnErr) return;
//      w\jsx('get-ssn');
    u\post("$base_url/ajax", ray('op sid data', 'ssn', session_id(), ''));
  }

  /**
   * Create a once-use password and return it.
   * @param string $name: login identifier (email, account record ID, or shortname) -- not used on production server
   * @return the once-use password
   */
  function oneTimePass($name) {
    global $base_url;
    $a = $this;
//    $verifying = !$a->stepDone['verifyemail'];
    $pass = u\randomString(R_CODE_LEN, 'word'); // use
    $expires = now() + HOUR_SECS * R_SIGNIN_HOURS;
    $a->update('oneTimePass', compact('pass', 'expires'));
    return $pass;
  } 

  /**
   * Say whether the password is acceptable.
   * @param string $password: the password supplied by the user
   * @param string $passFieldName: password field name (none if using only oneTimePass)
   * @param string $err: (RETURNED) the error message, if any
   * @return <password is good>
   */
  function passwordOkay($password, $passFieldName = '', &$err = '') {
    $a = $this;
    if ($a->oneTimePass) {
      extract(just('pass expires', $a->oneTimePass));
      if ($password == nn($pass)) return ($a->admin or now() < nn($expires)) ?: !($err = 'pass expired');
    }

    if (!strlen($a->$passFieldName)) return !$err = 'password required';
    require_once DRUPAL_ROOT . '/includes/password.inc';
    $hash = \_password_crypt('sha512', $password, $a->$passFieldName);
    return ($hash and $a->$passFieldName == $hash) ?: (!$err = 'bad login');
  }
  
  /**
   * Return the Community Admin's account record ID.
   */
  function cAdminUid() {
    return db\get('uid', 'users', 'community=:ctty AND :IS_CADMIN', ray('ctty', $this->community));
  }
  
  /**
   * Return the community admin's contact info.
   */
  function cAdminContact() {
    if (!$id = $this->cAdminUid()) return t('(no Community Admin)');
    $a = r\acct($id);
    return "$a->fullName - $a->email";
  }
  
  /**
   * Return an assoc of individual (or joint) account statistics.
   * @return [returnMo, return, cttyBeneMo, cttyBene]
   * OUT OF DATE and NOT CURRENTLY USED
   */
  public function j_stats() {
    $a = $this;
    $fields = 'returnMo return cttyBeneMo cttyBene';
    if (!$a->member or $a->isCtty) return ray($fields, 0, 0, 0, 0);
    
    $stats = ($stats = $a->stats) ? unserialize($stats) : [];

    if ($jid = $a->jid) {
      $j = r\acct($jid);
      $jstats = ($jstats = $j->stats) ? unserialize($jstats) : [];
      foreach ($stats as $k => $v) {
        $jv = nni($jstats, $k, 0);
        $stats[$k] = u\abbreviates('avg', $k) ? ($v + $jv) / 2 : ($v + $jv);
      }
      $created = round(($a->created + $j->created) / 2);
    } else $created = $a->created;
    
    extract($stats);
    $years = round((today() - strtotime('today', $created)) / DAY_SECS) * DAY_SECS / YEAR_SECS;
    // rounding is to assure consistency for tests, despite daylight savings time changes
    $returnMo = nn($avgBalPastMo, 0) > 0 ? 
      number_format(100 * 12 * nn($extraPastMo, 0) / $avgBalPastMo, 1)
      : (nn($benePastMo, 0) + nn($extraPastMo, 0) > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $return = ($years > 0 and nn($avgBalEver, 0) > 0) ? 
      number_format(100 * nn($extraEver) / $avgBalEver / $years, 1)
      : (nn($extraEver, 0) > 0 ? '&infin;' : number_format(100 * R_INFLATION_RATE, 1));
    $cttyBeneMo = u\fmtAmt(nn($giftsPastMo, 0) + max(0, nn($bankedPastMo, 0)) + nn($benePastMo, 0) * (1 + R_CC_RATE / 100));
///       debug(compact(ray('giftsEver bankedEver beneEver')));
    $cttyBene = u\fmtAmt(nn($giftsEver, 0) + max(0, nn($bankedEver, 0)) + nn($beneEver, 0) * (1 + R_CC_RATE / 100) + r\cttyPaidEver($a->community) / (nn($pAccts) ?: 1));

    return compact(ray($fields));
  }
   
  /**
   * Return an SMS number for the account.
   * @return: the number or null if none
   */
  public function smsNumber() {  
    $id = $this->id;
    return db\get('code', 'r_boxes', "uid=:id AND code REGEX '+[:digit:]{7,15}'", compact('id')); // was status=:SMS_PRIMARY
  }

  /**
   * Return the total waiting to be credited as a transfer FROM (or if negative result, TO) the member's bank.
   * @param numeric $combinable: (RETURNED) how much is waiting and checks haven't been printed yet (incoming only)
   * @param int $combineTxid: (RETURNED) record id of USD transfer request in r_usd that can be combined (if none, zero)
   */
  public function waitingFromBank(&$combinable = 0, &$combineTxid = 0) {
    $a = $this;
    $sql = <<< o
      SELECT SUM(amount) AS amt, SUM(IF(deposit, 0, amount)) AS combinable,
        MIN(IF(deposit OR amount=0, NULL, txid)) AS combineTxid
      FROM r_usd WHERE payee IN (:uids) AND NOT completed
o;
    extract(db\q($sql, ray('uids', $a->uids))->fetchAssoc());
    if ($combinable <= 0) $combinable = $combineTxid = 0;
    return $amt;
  }
	
  /**
   * Return the amount of pending bank transfers the member has already been credited with, against their credit line.
   */
  public function advances() {
    return db\sum('amount', 'r_usd', "payee IN (:uids) AND amount>0 AND completed AND :NOW-created<:DAY_SECS*:USDTX_DAYS", ['uids' => $this->uids]);
  }

  /**
   * Get the amount of any pending deposits of USD.
   * @return the amount.
   */
  public function getPendingDeposits() {
    $a = $this;
    $ids = empty($a->jid) ? $a->id : [$a->id, $a->jid];
    $res = db\sum('amount', 'r_usd', "payee IN (:ids) AND amount>0 and completed=0", ['ids'=>$ids]);
///       debug("$a->id getPendingDeposits() => $res");
    return $res;
  }

  /**
   * Get the amount of any pending deposits of USD.
   * @return the amount.
   */
  public function getApprovedInvoices() {
    $a = $this;
    $ids = empty($a->jid) ? $a->id : [$a->id, $a->jid];
    $res = db\sum('amount', 'r_invoices', "payer IN (:ids) AND amount>0 and status=:TX_APPROVED", ['ids'=>$ids]);
    return $res;
  }

  /**
   * Transfer funds to an account from a connected bank account or drawable Common Good account.
   * Always bring the balance up to zero or (if autorefill is yes) the target balance PLUS the requested amount.
   * Called for investments, gifts, invoice payment, and autorefills. So the only way to stay negative is not to do any of these.
   * @param numeric $amount: the amount needed
   * @param string $why: purpose of transfer
   * @return <success> (the funds were requested or drawn)
   */
  public function getFunds($amount, $why) {
    $a = $this;

    if ($amount <= 0) return FALSE;
    return $a->hasBank ? $a->bank($amount, $why) : ($a->draw($amount, $why) >= $amount);
  }
  
  /**
   * Transfer funds to or from a connected bank account.
   * @param numeric $amount: the amount to transfer FROM or (if negative) TO the bank
   * @param string $why: purpose of transfer
   * @param assoc $tx: forced field values, if any (when reversing an unsuccessful request)
   * @param string $newwhy: (RETURNED) actual message to tell account-owner about the transfer
   * @return <success> (a transfer request was made)
   */
  public function bank($amount, $why = '', $tx = [], &$newwhy = '') {
    $a = $this;
    global $channel;
    
    u\EXPECT($a->hasBank, 'banking with no bank');

    $amount0 = $amount;
    $automatic = ($channel == TX_CRON);
    $payee = $a->id;
    if ($tx) extract($tx);
    $okNow = ($amount < 0 or $a->bankOk); // "okay to create the request NOW"
    if (!$okNow) $a->verifyBank();
    $msg = 'banked';
    $done = FALSE;
    $previous = $total = NULL;
  
    if ($amount > 0) {
      $waiting = $a->waitingFromBank($combinable, $txid);
      $amount += $combinable;
      if ($a->refill) {
        $amount = max($amount, $a->achMin, R_ACHMIN, $a->minimum - $a->balance - $waiting);
        $amount = round(R_ACHMIN * ceil($amount / R_ACHMIN)); // round, if member has agreed to that deal
      } elseif ($automatic and $a->balance < 0) $amount = max($amount, $amount - $a->balance - $waiting);

      if ($combinable and $done = db\update('r_usd', compact(ray('txid amount')), 'txid')) {
        $msg .= '|combined';
        list ($previous, $total) = [u\fmtAmt($combinable), u\fmtAmt($amount)];
        $xid = db\get('xid', 'r_usd', compact('txid'));
      }
    }

    if (!$done) {
      u\setDft($created, $okNow ? now() : now() + 3 * DAY_SECS);
      u\setDft($completed, ($amount < 0 or ($okNow and $amount + $waiting <= -$a->floor)) ? $created : 0);
///    debug(compact(ray('done created okNow completed amount waiting')) + ['floor' => $a->floor]);

      $DBTX = \db_transaction();
      $txid = be\createUsdTransfer($a, $amount, $created, NULL, $xid);
      u\EXPECT((bool) $txid, 'saving usd record');
      if (nn($completed)) $completed = be\completeUsdTx($txid, $automatic, $completed); // completed is then boolean
      unset($DBTX);
    }

    u\EXPECT(!empty($xid), 'empty xid in acct::bank txid=' . $txid);
    if ($amount < 0 and $txid > 0) r\tellAdmin(t('outgoing bank transfer'), ray('who amount', $a->fullName, -$amount));
    
    if ($previous) $amount -= $combinable; // don't include previous amount in notice to member
    if ($amount > 0) $msg .= '|bank tx number' . (nn($completed) ? '|available now' : '');
    list ($action, $tofrom) = $amount < 0 ? [t('deposit'), t('to')] : [t('draw'), t('from')];
    $msg = tr($msg, ray('action tofrom amount checkNum previous total', $action, $tofrom, u\fmtAmt(abs(nn($amount))), $xid, $previous, $total));
    if (empty($why)) $why = '';
    r\notify($a->id, $newwhy = tr($msg, compact('why')));
    if ($amount > $amount0 and !$automatic) {
      $whyIncrease = $a->refill ? t('to meet your chosen auto-refill target. If this is more than you wanted, cancel or reverse this request, then turn off auto-refills in your Preference Settings before trying again.') : t('to bring your balance up to zero.');
      w\say(t('Your request has been increased ') . $whyIncrease);
    }

    return TRUE;
  }
	
  /**
   * Create a zero USD transfer record to verify the bank account.
   */
  public function verifyBank($channel = TX_SYS) {
    $a = $this;
    $info = ray('amount payee bankAccount', 0, $a->id, nni($a->vsecure, 'bankAccount') ?: NULL);
    if (test() and empty($bankAccount)) unset($info['bankAccount']); // otherwise t\verifyRecord fails
    if (db\exists('r_usd', $info)) return; // already being verified
    $txid0 = db\max('txid', 'r_usd', 'txid<999999');
    for ($txid = $txid0; $txid < 999999; $txid++) { // actual transfers start sometime after 999,999
      if (db\exists('r_usd', 'txid=:txid', compact('txid'))) continue;
      if ($txid = db\insert('r_usd', $info + compact(ray('txid channel')), 'txid')) break;
    }
    u\EXPECT($txid, 'ran out of low txids');
  }			

  /**
   * Automatically cashout accounts that choose to, leaving average weekly gross (over past 6 months) in the account. Weekly gross is figured as -6/26th of the floor (because there are 26 weeks in 6 months and floor is based on 1/6 of 6 months' gross).
   */
  public function cashout() {
    $a = $this;
    
    if (!$a->hasBank) return;
    if ($a->waitingFromBank($combinable) > 0) return; // no cashout if waiting to bring some in
    $cashout = 10 * floor(($a->balance - -$a->floor * 6 / 26) / 10);
    if ($cashout < R_ACHMIN) return;
    if (!$a->bank(-$cashout)) return;
  }
  
  /**
   * Suggest autorrefills or a higher minimum, etc. (because of a failed purchase).
   * This might make sense to use on the WEB interface also (just change the $channel line below), but the message would need to be added AFTER the basic error message.
   */
  public function suggestAuto() {
    $a = $this;
    global $channel; if (!in_array($channel, [TX_POS])) return;
		
    $web = ($channel == TX_WEB);

    if (!$web) $msg[] = 'you were short';
    $msg[] = $a->hasBank ? ($a->refill ? 'suggest higher target' : 'suggest refills') : 'how to fund';

    $args = [];
    if ($a->secret) {
      $args['_aSecret'] = $web ? w\atag('/settings/preferences') : $a->doLink('nosecret');
      $msg[] = 'be not secretive';
    }
    if (!$a->debt and $a->floor < 0) {
      $args['_aDebt'] = $web ? w\atag('/settings/preferences') : $a->doLink('debtok');
      $msg[] = 'try debt';
    }
		
    $msg = join('|', $msg);
    if ($web) return t($msg, $args); else r\notify($a->id, $msg, $args);
  }
	
  /**
   * Return the next suggested date, type, and description to contact this member for a standard checkin.
   * @param mixed $done: <asking because a checkin was just completed> or "activate"
   * @return [$type, $date] or ['', 0, ''] if none
   *   $type: a one-word call type
   *   $date: the suggested date
   */
  public function nextTickle($done = FALSE) {
    $a = $this;

    $now = now();
    $activate = ($done . '' == 'activate');
    if ($activate) {
      list ($done, $activated) = ['', $now];
    } else {
      if (!$a->member) {
        if ($a->nonudge or $now - $a->created < HOUR_SECS) return ['', 0];
        return [$a->task == ($a->co ? 'co' : 'person') ? 'setup' : 'pre', max(0, $a->created)]; // pre's (archaic) should be deleted
      } elseif (!$a->ok) return ['activate', $now];
      $activated = max($a->activated, strtotime('1/1/2013')); // max is for testing
    }
    
    if ($a->signupCo) $signupCo = w\signupCoDisplay($a->signupCo) . ',';
    $daysIn = ($now - $activated) / DAY_SECS; // how many days after activation are we
    $tickleDaysIn = $a->tickle ? ($a->tickle - $activated) / DAY_SECS : 0; // how many days after activation to tickle

    if ($activate or ($tickleDaysIn < 90 and $daysIn < ($done ? 8 : 90))) { // not welcoming if wrong time or done at right time
      $when = $activated + (($a->giftsDesc() and !$a->cttyA->isRegion) ? TICKLE_WELCOME : TICKLE_DELAYED) * DAY_SECS;
      return ['welcome', $when];
    }
    $yearsIn = max(1, round($daysIn / 365.25));
    if ($done and abs($yearsIn * 365.25 - $daysIn < 30)) $yearsIn++;
    return ['annual', strtotime("+$yearsIn years", $activated)]; // Annual
    // if (($daysIn + 30) mod 365 < 2 * 30) 
    //return [0, ''];
  }

  /**
   * Return a description of the members gift history. The total gifts include first planned gift, if none completed yet.
   * A gift is a transaction where one entry refers to the member and another entry refers to CG.
   * @param string $period: (RETURNED) frequency of latest gift
   * @param string $totalGifts: (RETURNED) total gifts with no mention of latest
   * @return: description of gifts (FALSE if none)
   */
  public function giftsDesc(&$period = '', &$totalGifts = '') {
    $a = $this;
    $gift = '';
    $subs = ['id' => $a->id];

    $sql = <<< X
      SELECT r.start AS recurStart, r.amount AS recurAmt, r.period, r.periods, h.honor, h.honored
      FROM tx_templates r
      LEFT JOIN r_honors h ON h.uid=r.from
      WHERE r.action=:ACT_PAY AND r.from=:id AND r.to=:CGID
      AND r.end IS NULL
X;
    $res = db\q($sql, $subs)->fetchAssoc();
    if ($res) extract($res);

    if ($res and $period) {
      $recurDesc = r\recurDesc($period, $periods);
      $recurAmt = u\fmtAmt($recurAmt);
      $recurStart = u\fmtDate($recurStart, TRUE);
      $gift = "<%b>$recurAmt</b> $recurDesc";
    } else { $period = $gift = ''; }

    $sql = <<< X
      SELECT created AS lastGiftDate, amt AS lastGift 
      FROM txs_noreverse
      WHERE uid1=:id AND uid2=:CGID AND :IS_GIFT
      ORDER BY created DESC LIMIT 1
X;
    $res = db\q($sql, $subs)->fetchAssoc();
    if ($res) {
      extract($res);
      $last = t('Last: %lastGift (%lastGiftDate)', 'lastGift lastGiftDate', u\fmtAmt($lastGift), u\fmtDate($lastGiftDate, TRUE));
      $gift = u\unite($gift, $last, ', ');
      if (nn($honored)) $gift = u\unite($gift, u\honorDesc($honor) . $honored, ', ');
    }
    
    $amt = $a->totalGifts();
    $totalGifts = ($amt) ? u\fmtAmt($amt) : null;
    if (!empty($totalGifts)) {
      $totalGifts = t('<%b>%totalGifts</b> to date', compact('totalGifts'));
    }
    $totalGifts .= trim(($a->roundup ? t(' +<%b>roundups</b>') : '') .
                        ($a->crumbs > 0 ? t(' +<%b>%crumbs% crumbs</b>', 'crumbs', $a->crumbs * 100) : ''));
    foreach (ray('totalGifts gift') as $k) $$k = tr($$k, '_b', 'b class="positive"'); // must do to each, not together

    return u\unite($totalGifts, $gift, ', ');
  }

  /**
   * Return a "no signin required" action. Called directly from a\export and ->doCode (above).
   * The account should be the recipient of the emailed link, if more than one account is involved.
   * @param string $op: what to do (NULL means allow any no-sign-in operation)
   * @param numeric $v: an amount, identifier
   * @param int $expire: number of days until link expires
   * @param assoc $info: other parameters (sql, subs, etc.)
   * @see also r\Web\rdo()
   */
  function doCode($op = NULL, $v = NULL, $expire = 90, $info = []) {
    if (isset($expire)) $expire = now() + $expire * DAY_SECS;
    $qid = $this->mainQid;
    foreach (ray('op qid v expire') as $k) if (isset($$k)) $info[$k] = $$k;
    return u\cryRay($info);
  }
  
  /**
   * Return a link to a "no signin required" code.
   * @return <a> tag guts for a clickable link that will do something without requiring the member to sign in
   */
  function doLink($op = NULL, $v = NULL, $expire = 90, $info = []) {
    return w\atag(BASE_URL . "/do/" . $this->doCode($op, $v, $expire, $info));
  }
  
  /**
   * Set the bit (identified by number or name) in the "risks" integer bit collection field.
   * @param mixed $bit: number of bit to set (0 - 31) or name of bit
   * @param bool $on: whether to set it ON or OFF
   */
  public function setRisk($bit, $on = TRUE) {$this->setBit($this::riskBit($bit), $on, 'risks');}
    
  public function risk($bit) {return u\getBit($this->risks ?: 0, $this::riskBit($bit));}
  
  /**
   * Return the bit number for risk bit name.
   * @param mixed $bit: the bit name or number
   * @return the bit number
   */
  private static function riskBit($bit) {
    if (is_numeric($bitName = $bit)) return $bit;
    $acctRiskBits = array_flip(array_keys(ray(K_ACCT_RISKS)));
    $txRiskBits = array_flip(array_keys(ray(K_TX_RISKS)));
    return is_numeric($bit = nni($acctRiskBits, $bitName)) ? $bit : $txRiskBits[$bitName];
  }
  
  //  private static function flagBit($bit) {return is_numeric($bit) ? $bit : u\consta('b', $bit);}
  public function coCan($bit = NULL) {return u\getBit($bit <= B_MAX ? $this->coFlags : $this->coFlags2, $bit);}
  public function setCoBit($bit, $on = TRUE) {$this->setBit($bit, $on, 'coFlags');}
  
  public function setCoCans($cans) {
    $coFlags = $this->coFlags;
    for ($i = 0; $i < 2 * APP_CAN_BITS; $i++) {
      $bit = u\bit(APP_CANS + $i);
      $coFlags = isset($cans[$i]) ? ($coFlags | $bit) : ($coFlags & ~$bit);
    }
    $this->update(compact('coFlags'));
  }

  /**
   * Set all account risk bits at once (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setRisks($values) {
    if (!is_array($values)) return; // this happens in testing
    $risks = $this->risks;
    $riskBits = array_values(just(K_ACCT_RISKS_EDITABLE, array_flip(array_keys(ray(K_ACCT_RISKS))))); // editable risk bits
    foreach ($riskBits as $bit) u\setBit($risks, $bit, isset($values[$bit]));
    $this->update(compact('risks')); // update all at once, for efficiency
  }
  
  /**
   * Set all appropriate bits in the flags field (called from formSummary for community admins)
   * @param array $values: numeric array of bit values (eg [3 => 3, 5 => 5])
   */
  public function setBits($values) {
    $a = $this;
    u\setDft($values, []); // fails in arg list (dunno why)
    $flags = $a->flags;
    foreach ($a->adminables() as $bitName) { // set all these on or off
      //      if (substr($bitName, 0, 1) == 'u') continue; // lowercase u means undefined
      $bit = u\consta('b', $bitName);
      $on = isset($values[$bit]); // isset because bit 0 is 0 when checked
      u\setBit($flags, $bit, $on);
    }
    $a->update(compact('flags'));
  }  

  /**
   * Say whether another active account has the same address
   */
  public function dupAddr() {
    $a = $this;
    if (!$address = $a->address) return FALSE;
    $q = db\q('SELECT uid FROM users WHERE :IS_OK AND uid<>:id AND zip=:zip', ray('id zip', $a->id, $a->zip));
    while ($row = $q->fetchAssoc()) if (r\acct($row['uid'])->address = $address) return TRUE;
    return FALSE;      
  }

  /**
   * Change the account's community.
   * @param int $newCtty: the new community uid
   * @param bool $retro: (UNUSED) <change rewards transactions retroactively>
   * @param string $err: (RETURNED) the error message, if any
   * @return <success>
   */   
  public function changeCtty($newCtty, $retro = FALSE, &$err = '') {
    $a = $this;
    if (!db\exists('users', 'uid<1 AND uid=:newCtty', compact('newCtty'))) return !$err = 'bad ctty';
    
    $a->update('community', $newCtty);
    return TRUE;
  }

  /**
   * Set the account's latitude and longitude.
   * For example: eachA(function ($a) {$a->setLocus();}, 'latitude=0 AND longitude=0');
   *
   * Choices for geocoding services:
   * https://api.opencagedata.com/geocode/v1/json?q=ADDRESS&key=API_KEY (free for up to 2,500 a day)
   * https://maps.googleapis.com/maps/api/geocode/json?address=ADDRESS&key=API_KEY (we are not signed up yet, 0.5c each)
   * https://geocoding.geo.census.gov/geocoder/locations/onelineaddress?format=json&benchmark=Public_AR_Current&address=ADDRESS (no API_KEY needed, but fails 7% of the time and no way to approximate the address)
   */
  public function setLocus($lat = NULL, $lon = NULL) {
    $a = $this;
    if (!is_null($lat)) return $a->update('latitude longitude', $lat, $lon);
    
    list ($lat, $lon, $zip) = u\getLocus($a->address, $a->city, $a->state, $a->zip);
    
    if (!$lat and !$lon) {
      $a->setRisk('addrOff');
      return r\tellAdmin(t('setLocus <%a>returned</a> no match', '_a', w\atag($url)));
    } else $a->setLocus($lat, $lon);
  }    
   
  /**
   * Say whether this settings/agent has the permission.
   * @param int $bit: the permission in question (DEFAULT B_READ)
   */
  public function can($bit = B_READ) {
    $a = $this;
    
    if ($a->isCanonic and in($bit, B_MEMBER, B_CONFIRMED, B_OK, B_NONUDGE, B_DEBT)) return true;

    if ($bit <= B_MAX) { // ordinary bits
      $can = (bool) ($a->flags & (1 << $bit)); // these are easy. be efficient.
      if (in($bit, [B_OADMIN, B_ADMIN2, B_CADMIN2, B_CADMIN, B_ADMIN])) {
        if ($a->id == 1) return TRUE; // this didn't use to be necessary (9/20/2017)
        if (!$a->proSe) return ($aa = $a->agentA and $aa->can($bit)); // admin permissions are for agent instead (in tests, agent sometimes doesn't exist)
        if (!$can and $bit < (R_ADMIN_CAN_MANAGE_CTTYS ? B_ADMIN : B_CADMIN)) return $a->can($bit + 1); // not this admin bit, maybe the next higher? IMPORTANT NOTE: this gives cAdmin2 Admin2 permission, so always use ->isAdmin2 rather than ->admin2 unless you WANT cAdmin2 to have the permission in question
      }
      return $can;
    }

    if ($bit == B_CTTYUP) return $a->cttyA->up;

    if ($bit == B_BANK) return $a->hasBank; // might get set after getCans() is called
    if ($bit == B_CLOSED) return $a->closed;
    $cans = nn(self::$perms[$a->id][$a->agentId]) ?: $a->getCans($bit);
    return $cans[$bit];
  }

  /**
   * Set up permissions (::$perms) if we haven't yet
   * @return the permissions array for this account
   */
  private function getCans($bit) {
    $a = $this;
    $aa = $this->agentA;
    $id = $a->id;
    
    $cans[B_PERSON] = !$a->can(B_CO);
    if ($id == 1) $cans[B_ADMIN] = TRUE;

    $perm = $a->closed ? B_READ
      : ($a->proSe ? B_MANAGE
         : (($aa->can(B_CADMIN) and $a->community == $aa->community) ? B_MANAGE : 0) );
      
    if (!$perm) $perm = max(B_RELATED + $a->permission,
      ($aa->can(B_OADMIN) or $aa->can(B_ADMIN2) 
        or ($aa->can(B_CADMIN2) and $a->community == $aa->community)) ? B_READ : 0);
      
    for ($i = B_RELATED; $i <= B_MANAGE; $i++) $cans[$i] = ($i <= $perm); // set all, even the false ones

    $cans[B_DEV] = (isDEV or $aa->can(B_ADMIN)); // used in menu system for tests page, etc.
    //    if ($cans[B_MANAGING_CTTY] = ($aa->can(B_CADMIN) and $id == $a->community)) $cans[B_BUY] = TRUE;
    $cans[B_MANAGING_CTTY] = ($aa->can(B_CADMIN) and $id == $a->community);

    if ($aa->can(B_ADMIN) and R_ADMIN_CAN_MANAGE_CTTYS) { // temporary extra power, until communities are independent
      $cans[B_READ] = $cans[B_SCAN] = $cans[B_SELL] = $cans[B_BUY] = $cans[B_MANAGE] = TRUE;
    }
    
    // Lastly, place restrictions on buying and selling

    if ($a->trialco) $cans[B_BUY] = FALSE; // trial companies can't buy
//    if ($a->co and $a->task == 'co2') $cans[B_BUY] = $cans[B_SELL] = FALSE; // co working on co2 can't do squat
    if (!$a->can(B_OK)) $cans[B_SELL] = $cans[B_BUY] = FALSE; // inactive accounts can't transact
    if ($a->underage) $cans[B_DEBT] = FALSE; // credit card regulations say no credit line if underage
    
    ksort($cans); // easier to debog
    return self::$perms[$id][$a->agentId] = $cans;
  }

  /**
   * Encrypt the highly sensitive data private key for a new regional admin's sign-in form.
   * @param string $vKey: key text (PEM-formatted or not) or file path with key text
   *   If $vKey is omitted, get it from the current administrator
   *   WARNING: This function invalidates an admin's flash drive sign-in form.
   * @return the encrypted private key (vKeyE), encrypted with the account's own password (vKeyPw).
   */
  public function makeVKeyE($vKey = '') {
    $a = $this;
    if (!$vKey = u\unfmtKey($vKey) and !$vKey = r\vKey()) return t('No private key given or available.');
    $a->update('vKeyPw', $vKeyPw = openssl_random_pseudo_bytes(32));
    if (isDEV) \setV('vKeyPw', $vKeyPw); // otherwise this gets lost during testing
    $vKeyE = u\cry('R', $vKey, FALSE, $vKeyPw);
    return u\b64encode($vKeyE); // ready for signin form on flash drive
  }
	
  /**
   * Call a function for each co-branding partner for whom the current account is a customer.
   * @param function(coA, custA, custCode) $func: the function to call, with three parameters:
   *   coA: company account
   *   custA: customer account
   *   custCode: the company's identifier for the customer
   */
  public function eachPartner($func) {
    $sql = 'SELECT main, code FROM r_relations WHERE other=:id AND :IS_CUSTOMER ORDER BY code';
    $res = q($sql, ['id' => $this->id])->fetchAllKeyed();
    foreach ($res as $main => $code) $func(r\acct($main), $this, $code);
  }
  
  /**
   * Return specified account's profile picture, with markup
   * @param bool $unique: should the markup force reloading the image
   * @return: markup to display the account's picture (with a default image if none or not permitted)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoHtml($small = FALSE, $unique = FALSE) {
    $a = $this;
    return '<div id="user-picture"><img src="' . $a->photoSrc($small, $unique) . '" alt="profile picture" /></div>';
  }
  
  /**
   * Return src attribute for specified account's profile picture, no markup, just the src
   * @param bool $unique: should the markup force reloading the image
   * @return: value for the src attribute to display the account's picture (with a default image if none or not permitted)
   * Use result with DRUPAL_ROOT . $result OR $base_url . $result
   */
  public function photoSrc($small = FALSE, $unique = FALSE) {
    $a = $this;
    global $base_url;
    if ($unique) $unique = '&t=' . now();
    $thing = $small ? 'thumb' : 'photo';
    $qid = $a->co ? "qid=$a->mainQid" : '';
    //    if (!$a->co) $qid .= "/$a->cardCode";
    return "$base_url/account-$thing/$qid$unique";
  }
  
  /**
   * Get and store SSN verification from 3rd party (in the background).
   * ssn step is marked done if all of the following are true:
   * . supplied last name (dba or legal) matches
   * . at least one other piece of name (dba or legal) matches, that has at least 4 letters
   * . birth date matches
   * . person is not dead
   * @param bool $force: redo search
   * @return the data
   */
  public function ssnCheck($force = FALSE) {
    $a = $this;
    if (!$a->hasFid) return t('No SSN yet.');;
    $fid = $a->vsecure['federalId'];
    if ($fid == '000000000') return t('Nonmember SSN.');
    if ($fid == '999999999') return t('SSN is a test.');
    //    if (u\isEncrypted($a->federalId)) return t('SSN available only to superAdmin');
    if ($a->ssnData and !u\starts($a->ssnErr, SSN_TIMEOUT_MSG) and !$force) return $a->ssnData;
    
    $max = 5;
    for ($i = 0; $i < $max; $i++) {
      if ($ssnData0 = u\ssnLookup($a->federalId) and !mb_strpos($ssnData0, 'RequestTimedOutException')) break;
    }
    if ($i == $max) return $a->ssnErr(SSN_TIMEOUT_MSG . t(' on %max tries.', compact('max')));

    $xml = simplexml_load_string($ssnData0);
    $json = json_encode($xml);
    $ssnData = json_decode($json, TRUE);
    if (!is_array($d = $ssnData['searchResults']) or $ssnData['ResultCount'] + 0 <= 0) { // 0 for tests, <=0 for failure
      return $a->ssnErr(t('No SSN data available: ') . pr($ssnData0));
    }
    unset($ssnData['searchResults']['ssn']); // has first 5 digits of SSN -- don't store it
    $a->update(compact('ssnData'));
    if (nn($d['deathsearchresults'])) return $a->ssnErr(t('The person is dead (?).'), $ssnData);
    
    list ($first1, $last1, $mid1) = u\parseName($a->fullName, TRUE);
    list ($first2, $last2, $mid2) = u\parseName($a->legalName, TRUE);
    foreach (ray('first1 last1 first2 last2') as $k) $$k = mb_strtolower($$k);
    
    $Ls = $Fs = $DOBs = [];
    $names = nn($d['ssnnames']['ssnname']);
    if (nni($names, 'lastname')) $names = [$names]; // handle case of just one name
    
    foreach ($names as $one) {
      $one = (object) $one;
      $name = u\ssnName($one, $F, $M, $L);
      $Ls[] = mb_strtolower($L);
      if (mb_strlen($F) > 1) $Fs[] = mb_strtolower($F);
      if ($M) foreach (explode(' ', mb_strtolower($M)) as $F) {
          if (mb_strlen($F) > 1) $Fs[] = $F;
        }
      if (nn($one->dob)) $DOBs[] = strtotime($one->dob);
    }
    
    if (!array_intersect([$last1, $last2], $Ls)) return $a->ssnErr(t('Last name does not match.'), $ssnData);
    if (!array_intersect([$first1, $first2, $mid1, $mid2], $Fs)) return $a->ssnErr(t('First name does not match.'), $ssnData);

    if ($DOBs) {
      if (!in($a->dob, $DOBs)) return $a->ssnErr(t('bad birthdate'), $ssnData);
    } else {
      $a->ssnErr(t('Cannot verify birthdate'), $ssnData);
      $a->setRisk('dobOff'); // nothing to compare, so don't ask member to retype dob
    }
    
    $a->stepDone('verifyid');
    $a->stepDone('ssn');
    return $a->ssnData;
  } 
    
  /**
   * Try to transfer funds from payer to payee for a pre-approved payment.
   * @param int $payee: record ID of recipient -- expected to be an active account, 
   *   but payer can be a not-yet-activated account (to be invoiced) for gifts to CG
   * @param numeric $amount: payment amount
   * @param string $desc: description of payment
   * @param assoc $data: extra data for transaction or invoice
   * @param int $recursId: record ID of related record in tx_templates (if any)
   * @return TRUE if the funds were successfully transferred (otherwise the payer is invoiced).
   */
  public function payApproved($payee, $amount, $desc, $goods, $data = [], $recursId = 0) {
    $a = $this;
    $payeeA = r\acct($payee);
    u\EXPECT($payeeA->ok, 'inactive recipient');
    if ($payee != CGID) u\EXPECT($a->ok, 'inactive payer'); // not-yet-active accounts can be invoiced for gifts to CG

    if ($a->ok) {
      list ($ok, $msg, $args) = be\transfer('payment', $a, $payeeA, $amount, $desc, $goods, $data, $recursId);
      if ($ok) return TRUE;
    }
    $data['status'] = TX_APPROVED;
    list ($ok, $msg, $args) = be\invoice($payeeA, $this, $amount, $desc, $goods, $data, $recursId);
    u\EXPECT($ok, t('approved invoice from account %payee failed in payApproved: ', compact('payee')) . t($msg, $args));
    return FALSE;
  }

  /**
   * Return the account's total gifts to the Common Good.
   */
  function totalGifts() {
    return db\sum('amt', 'txs_noreverse', 'uid1=:id AND uid2=:CGID AND :IS_GIFT', ['id' => $this->id ]);
  }
  
  /**
   * Set ssnData to an error message and maybe more
   * @param string $s: the error message
   * @param assoc $ssnData: whatever ssn Data we received from the lookup service
   */
  public function ssnErr($s, $ssnData = []) {
    $this->update('ssnData', $res = $ssnData + [SSN_ERR_INDEX => $s]);
    return $res;
  }

  /**
   * Say whether receiving the given amount will require an SSN where we don't have it yet.
   */
  public function needSsnFor($amt) {
    $a = $this;
    if ($a->co or $a->hasFid) return FALSE;
    if (!$res = db\get('SUM(amt) AS tot, COUNT(eid) AS cnt', 'txs_noreverse', 'created>:jan1 AND uid2=:myid AND type<>:E_BANK', ray('jan1 myid', strtotime(date('Y-01-01')), $a->id))) return FALSE;    
    extract($res);
    return !r\no1099k($tot + $amt, $cnt + 1, $a->st);
  }
  
  /**
   * Record latest account access
   */
  public function accessed() {
    global $channel;
    $a = $this;
    $info = ray('access lastip', now(), $_SERVER['REMOTE_ADDR']);
    if ($channel == TX_WEB) {
      $info['login'] = now();
      if ($a->ok) r\ipok($a->id);
    }
    $a->update($info);
  }
  
  /**
   * Return the rough (physical) location of the entity with the given account (city, state, non-US country).
   * @param bool $complete: if TRUE, include the street address
   */
  public function location($complete = FALSE) {
    $a = $this;
    $country = realCountry($a->country);
    $result = [];
    if ($complete) $result[] = (string) $a->address; // (string) in case address is NULL
    $result[] = $a->city;
    $result[] = $a->st . (($complete and $a->zip) ? ' ' . $a->zip : '');
    if ($a->country != R_COUNTRY_ID) $result[] = mb_strtoupper($country);
    foreach ($result as $key => $value) if ($value === '') unset($result[$key]);
    return join(', ', $result);
  }
  
  private function hasVSecure($fld) {return (nni($this->vsecure, $fld, '') !== '');}

  public function isMe($uid) {return ($uid == $this->id or $uid == $this->jid);}
  public function codeHash() {return u\hash($this->cardCode());}
  public function o($k) {return $this->{'o_' . $k};}
  public function api($etc = '') {return $this->website ? tr(CO_API_URL, 'website etc', $this->website, $etc) : '';}
  public function lastTx($where = 1, $subs = []) { return r\Tx::lastTx([$this->id, $this->jid], $where, $subs); }
  public function lastTxDesc() {return ($tx = $this->lastTx) ? t(' (Last tx: %dt)', 'dt', u\fmtDate($tx->created, TRUE)) : '';}
  public function isBank() {return r\isBank($this->id);}
  public function nameAndEmail() {return [$this->email => $this->fullName];}
  public function nameAndQid() {return "$this->fullName ($this->mainQid)";}
  public function firstCo() {return db\get('fullName', 'r_relations r INNER JOIN users u ON r.main=u.uid', 'r.permission>0 AND r.other=:id AND u.:IS_CO ORDER BY r.created LIMIT 1', ['id' => $this->id]);}
  public function adminables() {
    $res = ray(B_ADMINABLE . ($this->admin ? ' admin2' : '') . ($this->superAdmin ? ' admin' : ''));
    return array_values($this->isCtty ? array_intersect($res, ray(B_CTTY_BITS)) : array_diff($res, ray(B_CTTY_BITS)));
  }

} // end of class

/**
 * Return an account object for the described account.
 * call by:
 *   r\acct()       (returns current account)
 *   r\acct($uid)
 *   r\acct($main, $agent)
 *   r\acct($main, $agent, $error)
 *   r\acct($email)
 * @param int $uid: account uid
 * @param int $main: main account uid
 * @param int $agent: agent uid
 * @param string $email: email address for the account
 * @param string $error: error message, if any
 * @return the appropriate account object (FALSE if none)
 */
function acct($uid = '', $agent = '', &$error = '') {
///    print_r("acct($uid, $agent, $error)<br>");
  u\EXPECT(!is_array($uid), 'array uid'); // otherwise hangs (at least for a drupal field array)
  global $mya; // use this ONLY in this class file
  if (!$uid) return $mya ?: (!$error = 'There is no current account.');
  
  if (mb_strpos($uid, '@')) {
    $uid = db\get('uid', 'users', 'email=:email ORDER BY :IS_CO', ['email' => u\cry('P', $uid)]);
  } elseif (FALSE and preg_match('/[0-9]( |-|\\)) ?[0-9]{4}/', $uid)) {
    $uid = db\get('uid', 'users', 'phone=:phone ORDER BY :IS_CO', ['phone' => u\cry('P', u\fmtPhone($uid, '+n'))]);
  }
  if (!$ua = r\Acct::viable($uid, $agent, $error, TRUE)) return FALSE;
  return new r\Acct($ua); // the only place we call new r\Acct() with a flat array (meaning an existing account)
}

/**
 * Return an account object for the agent of the given account.
 */
function agent($uid = '') { $a = r\acct($uid); return $a ? $a->agentA : NULL; }

/**
 * Set the current account.
 * If there is no account signed in, set the agent also.
 * @param mixed $myid: the new account or account ID (if NULL, sign out. If '', get from sessions)
 * @param assoc $sta: (MODIFIED) if passed, gets ['uid'] set, to sign the account in
 * NOTE: $sta works only before displaying a page, not before redirecting (\session_regenerate does not appear to work).
 * @return the new account
 */
function setAcct($myid = '', &$sta = NULL) {
  global $mya;
  global $user;
  global $channel; 
  if (is_object($myid)) list ($myid, $agentId) = [$myid->id, $myid->agentId]; else $agentId = FALSE;
  if ($sta) $sta['uid'] = $myid;

  if (is_null($myid)) { // sign out
    $user = obj('uid', 0);
    w\svar('myid', NULL); w\svar('agentId', NULL);
    return $mya = NULL;
  }

  if ($myid) w\svar('myid', $myid); else $myid = w\svar('myid') ?: (w\svar('agentId') ?: 0);
  if (!$agentId and !$agentId = w\svar('agentId')) w\svar('agentId', $agentId = $myid);
  if ($sid = session_id()) db\update('sessions', ray('uid acct ssid', $agentId, $myid, $sid), 'ssid');
  w\svar('agentId', $agentId); w\svar('myid', $myid); // redo in case we're testing
  if (empty($user)) $user = obj('uid', $myid); else $user->uid = $agentId;
  if (!$myid) return $mya = NULL;

  $a = r\acct($myid, $agentId);
  if ($a->proSe or !$a->admin2) $a->accessed(); // admin access doesn't count
  return $mya = $a;
}

function taskSteps($task) {return $task ? u\consta('s', $task) : '';}
function allSteps() {return array_flip(array_keys(ray(S_ALL)));} // point step bit names to bit numbers
